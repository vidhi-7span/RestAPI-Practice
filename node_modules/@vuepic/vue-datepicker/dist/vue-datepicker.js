import { openBlock as D, createElementBlock as V, createElementVNode as oe, unref as f, reactive as It, computed as W, ref as X, toRef as Qt, watch as yt, h as za, render as Zn, defineComponent as Oe, renderSlot as te, createCommentVNode as z, normalizeClass as he, withKeys as le, createBlock as ve, withModifiers as be, onMounted as je, normalizeStyle as Ze, normalizeProps as Pe, mergeProps as Ye, Fragment as de, createTextVNode as et, toDisplayString as Ne, onBeforeUpdate as Wa, nextTick as st, onUnmounted as Nn, renderList as De, withDirectives as jt, vShow as Kt, withCtx as ie, createVNode as ze, Transition as $t, createSlots as Fe, useSlots as ht, guardReactiveProps as He, resolveDynamicComponent as In, getCurrentScope as ja, onScopeDispose as Ka, isRef as Qn, Teleport as Ga } from "vue";
import { format as rt, isBefore as Rt, isEqual as kt, isAfter as Yt, set as we, setHours as ya, setMinutes as ha, setSeconds as Bn, setMilliseconds as En, getYear as ge, getMonth as me, setMonth as Za, setYear as ft, addMonths as vt, subMonths as Ot, isValid as Gt, parseISO as Qa, eachDayOfInterval as pa, getHours as Qe, getMinutes as Je, getSeconds as wt, startOfWeek as ba, endOfWeek as qa, parse as An, isDate as Xa, addYears as ka, subYears as wa, addDays as ct, getDay as Ja, differenceInCalendarDays as xa, add as Da, sub as er, getWeek as tr, getISOWeek as nr, isSameQuarter as qn, eachQuarterOfInterval as ar, startOfYear as rr, endOfYear as lr, startOfQuarter as or, endOfQuarter as Xn } from "date-fns";
function Bt() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
      }),
      oe("path", {
        d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      oe("path", {
        d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      }),
      oe("path", {
        d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
      })
    ]
  );
}
Bt.compatConfig = {
  MODE: 3
};
function Ma() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
      }),
      oe("path", {
        d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Ma.compatConfig = {
  MODE: 3
};
function Fn() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Fn.compatConfig = {
  MODE: 3
};
function Hn() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
      })
    ]
  );
}
Hn.compatConfig = {
  MODE: 3
};
function Vn() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
      }),
      oe("path", {
        d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
      })
    ]
  );
}
Vn.compatConfig = {
  MODE: 3
};
function Ln() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
      })
    ]
  );
}
Ln.compatConfig = {
  MODE: 3
};
function Un() {
  return D(), V(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 32 32",
      fill: "currentColor",
      "aria-hidden": "true",
      class: "dp__icon"
    },
    [
      oe("path", {
        d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
      })
    ]
  );
}
Un.compatConfig = {
  MODE: 3
};
function zn(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var $a = { exports: {} };
(function(e) {
  function n(a) {
    return a && a.__esModule ? a : {
      default: a
    };
  }
  e.exports = n, e.exports.__esModule = !0, e.exports.default = e.exports;
})($a);
var sr = $a.exports, Sn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    if (t === null || t === !0 || t === !1)
      return NaN;
    var r = Number(t);
    return isNaN(r) ? r : r < 0 ? Math.ceil(r) : Math.floor(r);
  }
  e.exports = n.default;
})(Sn, Sn.exports);
var ir = Sn.exports;
const ur = /* @__PURE__ */ zn(ir);
var Pn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t) {
    var r = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
    return r.setUTCFullYear(t.getFullYear()), t.getTime() - r.getTime();
  }
  e.exports = n.default;
})(Pn, Pn.exports);
var dr = Pn.exports;
const Jn = /* @__PURE__ */ zn(dr);
function cr(e, n) {
  var a = gr(n);
  return a.formatToParts ? vr(a, e) : mr(a, e);
}
var fr = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function vr(e, n) {
  try {
    for (var a = e.formatToParts(n), t = [], r = 0; r < a.length; r++) {
      var l = fr[a[r].type];
      l >= 0 && (t[l] = parseInt(a[r].value, 10));
    }
    return t;
  } catch (c) {
    if (c instanceof RangeError)
      return [NaN];
    throw c;
  }
}
function mr(e, n) {
  var a = e.format(n).replace(/\u200E/g, ""), t = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a);
  return [t[3], t[1], t[2], t[4], t[5], t[6]];
}
var mn = {};
function gr(e) {
  if (!mn[e]) {
    var n = new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), a = n === "06/25/2014, 00:00:00" || n === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
    mn[e] = a ? new Intl.DateTimeFormat("en-US", {
      hour12: !1,
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return mn[e];
}
function Wn(e, n, a, t, r, l, c) {
  var b = /* @__PURE__ */ new Date(0);
  return b.setUTCFullYear(e, n, a), b.setUTCHours(t, r, l, c), b;
}
var xn = 36e5, yr = 6e4, gn = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function jn(e, n, a) {
  var t, r;
  if (!e || (t = gn.timezoneZ.exec(e), t))
    return 0;
  var l;
  if (t = gn.timezoneHH.exec(e), t)
    return l = parseInt(t[1], 10), ea(l) ? -(l * xn) : NaN;
  if (t = gn.timezoneHHMM.exec(e), t) {
    l = parseInt(t[1], 10);
    var c = parseInt(t[2], 10);
    return ea(l, c) ? (r = Math.abs(l) * xn + c * yr, l > 0 ? -r : r) : NaN;
  }
  if (br(e)) {
    n = new Date(n || Date.now());
    var b = a ? n : hr(n), k = _n(b, e), P = a ? k : pr(n, k, e);
    return -P;
  }
  return NaN;
}
function hr(e) {
  return Wn(
    e.getFullYear(),
    e.getMonth(),
    e.getDate(),
    e.getHours(),
    e.getMinutes(),
    e.getSeconds(),
    e.getMilliseconds()
  );
}
function _n(e, n) {
  var a = cr(e, n), t = Wn(
    a[0],
    a[1] - 1,
    a[2],
    a[3] % 24,
    a[4],
    a[5],
    0
  ).getTime(), r = e.getTime(), l = r % 1e3;
  return r -= l >= 0 ? l : 1e3 + l, t - r;
}
function pr(e, n, a) {
  var t = e.getTime(), r = t - n, l = _n(new Date(r), a);
  if (n === l)
    return n;
  r -= l - n;
  var c = _n(new Date(r), a);
  return l === c ? l : Math.max(l, c);
}
function ea(e, n) {
  return -23 <= e && e <= 23 && (n == null || 0 <= n && n <= 59);
}
var ta = {};
function br(e) {
  if (ta[e])
    return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e }), ta[e] = !0, !0;
  } catch {
    return !1;
  }
}
var Ta = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, yn = 36e5, na = 6e4, kr = 2, Ee = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: Ta
};
function Cn(e, n) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e === null)
    return /* @__PURE__ */ new Date(NaN);
  var a = n || {}, t = a.additionalDigits == null ? kr : ur(a.additionalDigits);
  if (t !== 2 && t !== 1 && t !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]")
    return new Date(e.getTime());
  if (typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]")
    return new Date(e);
  if (!(typeof e == "string" || Object.prototype.toString.call(e) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var r = wr(e), l = Dr(r.date, t), c = l.year, b = l.restDateString, k = Mr(b, c);
  if (isNaN(k))
    return /* @__PURE__ */ new Date(NaN);
  if (k) {
    var P = k.getTime(), g = 0, S;
    if (r.time && (g = $r(r.time), isNaN(g)))
      return /* @__PURE__ */ new Date(NaN);
    if (r.timeZone || a.timeZone) {
      if (S = jn(r.timeZone || a.timeZone, new Date(P + g)), isNaN(S))
        return /* @__PURE__ */ new Date(NaN);
    } else
      S = Jn(new Date(P + g)), S = Jn(new Date(P + g + S));
    return new Date(P + g + S);
  } else
    return /* @__PURE__ */ new Date(NaN);
}
function wr(e) {
  var n = {}, a = Ee.dateTimePattern.exec(e), t;
  if (a ? (n.date = a[1], t = a[3]) : (a = Ee.datePattern.exec(e), a ? (n.date = a[1], t = a[2]) : (n.date = null, t = e)), t) {
    var r = Ee.timeZone.exec(t);
    r ? (n.time = t.replace(r[1], ""), n.timeZone = r[1].trim()) : n.time = t;
  }
  return n;
}
function Dr(e, n) {
  var a = Ee.YYY[n], t = Ee.YYYYY[n], r;
  if (r = Ee.YYYY.exec(e) || t.exec(e), r) {
    var l = r[1];
    return {
      year: parseInt(l, 10),
      restDateString: e.slice(l.length)
    };
  }
  if (r = Ee.YY.exec(e) || a.exec(e), r) {
    var c = r[1];
    return {
      year: parseInt(c, 10) * 100,
      restDateString: e.slice(c.length)
    };
  }
  return {
    year: null
  };
}
function Mr(e, n) {
  if (n === null)
    return null;
  var a, t, r, l;
  if (e.length === 0)
    return t = /* @__PURE__ */ new Date(0), t.setUTCFullYear(n), t;
  if (a = Ee.MM.exec(e), a)
    return t = /* @__PURE__ */ new Date(0), r = parseInt(a[1], 10) - 1, ra(n, r) ? (t.setUTCFullYear(n, r), t) : /* @__PURE__ */ new Date(NaN);
  if (a = Ee.DDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0);
    var c = parseInt(a[1], 10);
    return Sr(n, c) ? (t.setUTCFullYear(n, 0, c), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ee.MMDD.exec(e), a) {
    t = /* @__PURE__ */ new Date(0), r = parseInt(a[1], 10) - 1;
    var b = parseInt(a[2], 10);
    return ra(n, r, b) ? (t.setUTCFullYear(n, r, b), t) : /* @__PURE__ */ new Date(NaN);
  }
  if (a = Ee.Www.exec(e), a)
    return l = parseInt(a[1], 10) - 1, la(n, l) ? aa(n, l) : /* @__PURE__ */ new Date(NaN);
  if (a = Ee.WwwD.exec(e), a) {
    l = parseInt(a[1], 10) - 1;
    var k = parseInt(a[2], 10) - 1;
    return la(n, l, k) ? aa(n, l, k) : /* @__PURE__ */ new Date(NaN);
  }
  return null;
}
function $r(e) {
  var n, a, t;
  if (n = Ee.HH.exec(e), n)
    return a = parseFloat(n[1].replace(",", ".")), hn(a) ? a % 24 * yn : NaN;
  if (n = Ee.HHMM.exec(e), n)
    return a = parseInt(n[1], 10), t = parseFloat(n[2].replace(",", ".")), hn(a, t) ? a % 24 * yn + t * na : NaN;
  if (n = Ee.HHMMSS.exec(e), n) {
    a = parseInt(n[1], 10), t = parseInt(n[2], 10);
    var r = parseFloat(n[3].replace(",", "."));
    return hn(a, t, r) ? a % 24 * yn + t * na + r * 1e3 : NaN;
  }
  return null;
}
function aa(e, n, a) {
  n = n || 0, a = a || 0;
  var t = /* @__PURE__ */ new Date(0);
  t.setUTCFullYear(e, 0, 4);
  var r = t.getUTCDay() || 7, l = n * 7 + a + 1 - r;
  return t.setUTCDate(t.getUTCDate() + l), t;
}
var Tr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ar = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Aa(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0;
}
function ra(e, n, a) {
  if (n < 0 || n > 11)
    return !1;
  if (a != null) {
    if (a < 1)
      return !1;
    var t = Aa(e);
    if (t && a > Ar[n] || !t && a > Tr[n])
      return !1;
  }
  return !0;
}
function Sr(e, n) {
  if (n < 1)
    return !1;
  var a = Aa(e);
  return !(a && n > 366 || !a && n > 365);
}
function la(e, n, a) {
  return !(n < 0 || n > 52 || a != null && (a < 0 || a > 6));
}
function hn(e, n, a) {
  return !(e != null && (e < 0 || e >= 25) || n != null && (n < 0 || n >= 60) || a != null && (a < 0 || a >= 60));
}
var Rn = { exports: {} }, Yn = { exports: {} };
(function(e, n) {
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = a;
  function a(t, r) {
    if (t == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var l in r)
      Object.prototype.hasOwnProperty.call(r, l) && (t[l] = r[l]);
    return t;
  }
  e.exports = n.default;
})(Yn, Yn.exports);
var Pr = Yn.exports;
(function(e, n) {
  var a = sr.default;
  Object.defineProperty(n, "__esModule", {
    value: !0
  }), n.default = r;
  var t = a(Pr);
  function r(l) {
    return (0, t.default)({}, l);
  }
  e.exports = n.default;
})(Rn, Rn.exports);
var _r = Rn.exports;
const Cr = /* @__PURE__ */ zn(_r);
function Rr(e, n, a) {
  var t = Cn(e, a), r = jn(n, t, !0), l = new Date(t.getTime() - r), c = /* @__PURE__ */ new Date(0);
  return c.setFullYear(l.getUTCFullYear(), l.getUTCMonth(), l.getUTCDate()), c.setHours(l.getUTCHours(), l.getUTCMinutes(), l.getUTCSeconds(), l.getUTCMilliseconds()), c;
}
function Yr(e, n, a) {
  if (typeof e == "string" && !e.match(Ta)) {
    var t = Cr(a);
    return t.timeZone = n, Cn(e, t);
  }
  var r = Cn(e, a), l = Wn(
    r.getFullYear(),
    r.getMonth(),
    r.getDate(),
    r.getHours(),
    r.getMinutes(),
    r.getSeconds(),
    r.getMilliseconds()
  ).getTime(), c = jn(n, new Date(l));
  return new Date(l + c);
}
function oa(e) {
  return (n) => new Intl.DateTimeFormat(e, { weekday: "short", timeZone: "UTC" }).format(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`)).slice(0, 2);
}
function Or(e) {
  return (n) => rt(/* @__PURE__ */ new Date(`2017-01-0${n}T00:00:00+00:00`), "EEEEEE", { locale: e });
}
const Nr = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7];
  let r;
  if (e !== null)
    try {
      r = t.map(Or(e));
    } catch {
      r = t.map(oa(n));
    }
  else
    r = t.map(oa(n));
  const l = r.slice(0, a), c = r.slice(a + 1, r.length);
  return [r[a]].concat(...c).concat(...l);
}, Kn = (e, n) => {
  const a = [];
  for (let t = +e[0]; t <= +e[1]; t++)
    a.push({ value: +t, text: `${t}` });
  return n ? a.reverse() : a;
}, Sa = (e, n, a) => {
  const t = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((l) => {
    const c = l < 10 ? `0${l}` : l;
    return /* @__PURE__ */ new Date(`2017-${c}-01T00:00:00+00:00`);
  });
  if (e !== null)
    try {
      const l = a === "long" ? "MMMM" : "MMM";
      return t.map((c, b) => {
        const k = rt(c, l, { locale: e });
        return {
          text: k.charAt(0).toUpperCase() + k.substring(1),
          value: b
        };
      });
    } catch {
    }
  const r = new Intl.DateTimeFormat(n, { month: a, timeZone: "UTC" });
  return t.map((l, c) => {
    const b = r.format(l);
    return {
      text: b.charAt(0).toUpperCase() + b.substring(1),
      value: c
    };
  });
}, Ir = (e) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e], Se = (e) => {
  const n = f(e);
  return n != null && n.$el ? n == null ? void 0 : n.$el : n;
}, Br = (e) => Object.assign({ type: "dot" }, e), Pa = (e) => Array.isArray(e) ? !!e[0] && !!e[1] : !1, qt = {
  prop: (e) => `"${e}" prop must be enabled!`,
  dateArr: (e) => `You need to use array as "model-value" binding in order to support "${e}"`
}, Te = (e) => e, sa = (e) => e === 0 ? e : !e || isNaN(+e) ? null : +e, ia = (e) => e === null, Er = (e) => {
  if (e)
    return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0];
}, Fr = (e) => {
  const n = [], a = (t) => t.filter((r) => r);
  for (let t = 0; t < e.length; t += 3) {
    const r = [e[t], e[t + 1], e[t + 2]];
    n.push(a(r));
  }
  return n;
}, Nt = (e, n, a) => {
  const t = a ?? a === 0, r = n ?? n === 0;
  if (!t && !r)
    return !1;
  const l = +a, c = +n;
  return t && r ? +e > l || +e < c : t ? +e > l : r ? +e < c : !1;
}, Dt = (e, n) => Fr(e).map((a) => a.map((t) => {
  const { active: r, disabled: l, isBetween: c } = n(t);
  return {
    ...t,
    active: r,
    disabled: l,
    className: {
      dp__overlay_cell_active: r,
      dp__overlay_cell: !r,
      dp__overlay_cell_disabled: l,
      dp__overlay_cell_pad: !0,
      dp__overlay_cell_active_disabled: l && r,
      dp__cell_in_between: c
    }
  };
})), lt = (e, n, a = !1) => {
  e && n.allowStopPropagation && (a && e.stopImmediatePropagation(), e.stopPropagation());
}, ua = (e, n, a, t, r) => {
  const l = An(e, n.slice(0, e.length), /* @__PURE__ */ new Date());
  return Gt(l) && Xa(l) ? t || r ? l : we(l, {
    hours: +a.hours,
    minutes: +(a == null ? void 0 : a.minutes),
    seconds: +(a == null ? void 0 : a.seconds),
    milliseconds: 0
  }) : null;
}, Hr = (e, n, a, t, r) => {
  const l = Array.isArray(a) ? a[0] : a;
  if (typeof n == "string")
    return ua(e, n, l, t, r);
  if (Array.isArray(n)) {
    let c = null;
    for (const b of n)
      if (c = ua(e, b, l, t, r), c)
        break;
    return c;
  }
  return typeof n == "function" ? n(e) : null;
}, H = (e) => e ? new Date(e) : /* @__PURE__ */ new Date(), Vr = (e, n, a) => {
  if (n) {
    const r = (e.getMonth() + 1).toString().padStart(2, "0"), l = e.getDate().toString().padStart(2, "0"), c = e.getHours().toString().padStart(2, "0"), b = e.getMinutes().toString().padStart(2, "0"), k = a ? e.getSeconds().toString().padStart(2, "0") : "00";
    return `${e.getFullYear()}-${r}-${l}T${c}:${b}:${k}.000Z`;
  }
  const t = Date.UTC(
    e.getUTCFullYear(),
    e.getUTCMonth(),
    e.getUTCDate(),
    e.getUTCHours(),
    e.getUTCMinutes(),
    e.getUTCSeconds()
  );
  return new Date(t).toISOString();
}, We = (e) => {
  let n = H(JSON.parse(JSON.stringify(e)));
  return n = ya(n, 0), n = ha(n, 0), n = Bn(n, 0), n = En(n, 0), n;
}, ot = (e, n, a, t) => {
  let r = e ? H(e) : H();
  return (n || n === 0) && (r = ya(r, +n)), (a || a === 0) && (r = ha(r, +a)), (t || t === 0) && (r = Bn(r, +t)), En(r, 0);
}, Re = (e, n) => !e || !n ? !1 : Rt(We(e), We(n)), ye = (e, n) => !e || !n ? !1 : kt(We(e), We(n)), Ie = (e, n) => !e || !n ? !1 : Yt(We(e), We(n)), Xt = (e, n, a) => e != null && e[0] && (e != null && e[1]) ? Ie(a, e[0]) && Re(a, e[1]) : e != null && e[0] && n ? Ie(a, e[0]) && Re(a, n) || Re(a, e[0]) && Ie(a, n) : !1, Ge = (e) => {
  const n = we(new Date(e), { date: 1 });
  return We(n);
}, pn = (e, n, a) => n && (a || a === 0) ? Object.fromEntries(
  ["hours", "minutes", "seconds"].map((t) => t === n ? [t, a] : [t, isNaN(+e[t]) ? void 0 : +e[t]])
) : {
  hours: isNaN(+e.hours) ? void 0 : +e.hours,
  minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
  seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
}, mt = (e) => ({
  hours: Qe(e),
  minutes: Je(e),
  seconds: wt(e)
}), _a = (e, n) => {
  if (n) {
    const a = ge(H(n));
    if (a > e)
      return 12;
    if (a === e)
      return me(H(n));
  }
}, Ca = (e, n) => {
  if (n) {
    const a = ge(H(n));
    return a < e ? -1 : a === e ? me(H(n)) : void 0;
  }
}, Mt = (e) => {
  if (e)
    return ge(H(e));
}, Ue = (e, n) => n ? Rr(e, n) : e, Ra = (e, n) => n ? Yr(e, n) : e, da = (e) => e instanceof Date ? e : Qa(e), Ya = (e, n) => {
  const a = Ie(e, n) ? n : e, t = Ie(n, e) ? n : e;
  return pa({ start: a, end: t });
}, Lr = (e) => {
  const n = vt(e, 1);
  return { month: me(n), year: ge(n) };
}, Zt = (e, n, a) => {
  const t = ba(Ue(e, n), { weekStartsOn: +a }), r = qa(Ue(e, n), { weekStartsOn: +a });
  return [t, r];
}, Oa = (e, n) => {
  const a = {
    hours: Qe(H()),
    minutes: Je(H()),
    seconds: n ? wt(H()) : 0
  };
  return Object.assign(a, e);
}, at = (e, n, a) => [we(H(e), { date: 1 }), we(H(), { month: n, year: a, date: 1 })], xe = (e, n, a) => {
  let t = e ? H(e) : H();
  return (n || n === 0) && (t = Za(t, n)), a && (t = ft(t, a)), t;
}, Na = (e, n, a, t, r) => {
  if (!t || r && !n || !r && !a)
    return !1;
  const l = r ? vt(e, 1) : Ot(e, 1), c = [me(l), ge(l)];
  return r ? !zr(...c, n) : !Ur(...c, a);
}, Ur = (e, n, a) => Re(...at(a, e, n)) || ye(...at(a, e, n)), zr = (e, n, a) => Ie(...at(a, e, n)) || ye(...at(a, e, n)), Ia = (e, n, a, t, r, l, c) => {
  if (typeof n == "function" && !c)
    return n(e);
  const b = a ? { locale: a } : void 0;
  return Array.isArray(e) ? `${rt(e[0], l, b)}${r && !e[1] ? "" : t}${e[1] ? rt(e[1], l, b) : ""}` : rt(e, l, b);
}, pt = (e) => {
  if (e)
    return null;
  throw new Error(qt.prop("partial-range"));
}, zt = (e, n) => {
  if (n)
    return e();
  throw new Error(qt.prop("range"));
}, On = (e) => Array.isArray(e) ? Gt(e[0]) && (e[1] ? Gt(e[1]) : !0) : e ? Gt(e) : !1, Wr = (e) => we(H(), {
  hours: +e.hours || 0,
  minutes: +e.minutes || 0,
  seconds: +e.seconds || 0
}), bn = (e, n, a, t) => {
  if (!e)
    return !0;
  if (t) {
    const r = a === "max" ? Rt(e, n) : Yt(e, n), l = { seconds: 0, milliseconds: 0 };
    return r || kt(we(e, l), we(n, l));
  }
  return a === "max" ? e.getTime() <= n.getTime() : e.getTime() >= n.getTime();
}, ca = (e, n, a, t, r) => {
  const l = e ? Wr(e) : H(n);
  return Array.isArray(t) ? bn(t[0], l, a, !!n) && bn(t[1], l, a, !!n) && r : bn(t, l, a, !!n) && r;
}, kn = (e) => we(H(), mt(e)), jr = (e, n) => Array.isArray(e) ? e.map((a) => H(a)).filter((a) => ge(H(a)) === n).map((a) => me(a)) : [], _t = It({
  menuFocused: !1,
  shiftKeyInMenu: !1
}), Ba = () => {
  const e = (t) => {
    _t.menuFocused = t;
  }, n = (t) => {
    _t.shiftKeyInMenu !== t && (_t.shiftKeyInMenu = t);
  };
  return {
    control: W(() => ({ shiftKeyInMenu: _t.shiftKeyInMenu, menuFocused: _t.menuFocused })),
    setMenuFocused: e,
    setShiftKey: n
  };
}, ke = It({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), wn = X(null), Wt = X(!1), Dn = X(!1), Mn = X(!1), $n = X(!1), Be = X(0), Ce = X(0), it = () => {
  const e = W(() => Wt.value ? [...ke.selectionGrid, ke.actionRow].filter((h) => h.length) : Dn.value ? [
    ...ke.timePicker[0],
    ...ke.timePicker[1],
    $n.value ? [] : [wn.value],
    ke.actionRow
  ].filter((h) => h.length) : Mn.value ? [...ke.monthPicker, ke.actionRow] : [ke.monthYear, ...ke.calendar, ke.time, ke.actionRow].filter((h) => h.length)), n = (h) => {
    Be.value = h ? Be.value + 1 : Be.value - 1;
    let O = null;
    e.value[Ce.value] && (O = e.value[Ce.value][Be.value]), O || (Be.value = h ? Be.value - 1 : Be.value + 1);
  }, a = (h) => {
    if (Ce.value === 0 && !h || Ce.value === e.value.length && h)
      return;
    Ce.value = h ? Ce.value + 1 : Ce.value - 1, e.value[Ce.value] ? e.value[Ce.value] && !e.value[Ce.value][Be.value] && Be.value !== 0 && (Be.value = e.value[Ce.value].length - 1) : Ce.value = h ? Ce.value - 1 : Ce.value + 1;
  }, t = (h) => {
    let O = null;
    e.value[Ce.value] && (O = e.value[Ce.value][Be.value]), O ? O.focus({ preventScroll: !Wt.value }) : Be.value = h ? Be.value - 1 : Be.value + 1;
  }, r = () => {
    n(!0), t(!0);
  }, l = () => {
    n(!1), t(!1);
  }, c = () => {
    a(!1), t(!0);
  }, b = () => {
    a(!0), t(!0);
  }, k = (h, O) => {
    ke[O] = h;
  }, P = (h, O) => {
    ke[O] = h;
  }, g = () => {
    Be.value = 0, Ce.value = 0;
  };
  return {
    buildMatrix: k,
    buildMultiLevelMatrix: P,
    setTimePickerBackRef: (h) => {
      wn.value = h;
    },
    setSelectionGrid: (h) => {
      Wt.value = h, g(), h || (ke.selectionGrid = []);
    },
    setTimePicker: (h, O = !1) => {
      Dn.value = h, $n.value = O, g(), h || (ke.timePicker[0] = [], ke.timePicker[1] = []);
    },
    setTimePickerElements: (h, O = 0) => {
      ke.timePicker[O] = h;
    },
    arrowRight: r,
    arrowLeft: l,
    arrowUp: c,
    arrowDown: b,
    clearArrowNav: () => {
      ke.monthYear = [], ke.calendar = [], ke.time = [], ke.actionRow = [], ke.selectionGrid = [], ke.timePicker[0] = [], ke.timePicker[1] = [], Wt.value = !1, Dn.value = !1, $n.value = !1, Mn.value = !1, g(), wn.value = null;
    },
    setMonthPicker: (h) => {
      Mn.value = h, g();
    },
    refSets: ke
    // exposed for testing
  };
}, fa = (e) => ({
  menuAppearTop: "dp-menu-appear-top",
  menuAppearBottom: "dp-menu-appear-bottom",
  open: "dp-slide-down",
  close: "dp-slide-up",
  next: "calendar-next",
  previous: "calendar-prev",
  vNext: "dp-slide-up",
  vPrevious: "dp-slide-down",
  ...e ?? {}
}), Kr = (e) => ({
  toggleOverlay: "Toggle overlay",
  menu: "Datepicker menu",
  input: "Datepicker input",
  calendarWrap: "Calendar wrapper",
  calendarDays: "Calendar days",
  openTimePicker: "Open time picker",
  closeTimePicker: "Close time Picker",
  incrementValue: (n) => `Increment ${n}`,
  decrementValue: (n) => `Decrement ${n}`,
  openTpOverlay: (n) => `Open ${n} overlay`,
  amPmButton: "Switch AM/PM mode",
  openYearsOverlay: "Open years overlay",
  openMonthsOverlay: "Open months overlay",
  nextMonth: "Next month",
  prevMonth: "Previous month",
  nextYear: "Next year",
  prevYear: "Previous year",
  day: () => "",
  ...e ?? {}
}), va = (e) => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0, Gr = (e) => {
  const n = typeof e == "object" && e, a = {
    static: !0,
    solo: !1
  };
  if (!e)
    return { ...a, count: va(!1) };
  const t = n ? e : {}, r = n ? t.count ?? !0 : e, l = va(r);
  return Object.assign(a, t, { count: l });
}, Zr = (e, n, a) => e || (typeof a == "string" ? a : n), Qr = (e) => typeof e == "boolean" ? e ? fa({}) : !1 : fa(e), qr = (e) => {
  const n = {
    enterSubmit: !0,
    tabSubmit: !0,
    openMenu: !0,
    selectOnFocus: !1,
    rangeSeparator: " - "
  };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: !0 } : { ...n, enabled: e };
}, Xr = (e) => ({
  months: [],
  years: [],
  times: { hours: [], minutes: [], seconds: [] },
  ...e ?? {}
}), Jr = (e) => ({
  showSelect: !0,
  showCancel: !0,
  showNow: !1,
  showPreview: !0,
  ...e ?? {}
}), xr = (e) => {
  const n = { input: !1 };
  return typeof e == "object" ? { ...n, ...e ?? {}, enabled: !0 } : {
    enabled: e,
    ...n
  };
}, el = (e) => ({ ...{
  allowStopPropagation: !0,
  closeOnScroll: !1,
  modeHeight: 255,
  allowPreventDefault: !1,
  closeOnClearValue: !0,
  closeOnAutoApply: !0,
  noSwipe: !1,
  keepActionRow: !1,
  onClickOutside: void 0
}, ...e ?? {} }), Ae = (e) => {
  const n = () => {
    const K = e.enableSeconds ? ":ss" : "";
    return e.is24 ? `HH:mm${K}` : `hh:mm${K} aa`;
  }, a = () => e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? n() : e.weekPicker ? "MM/dd/yyyy" : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${n()}` : "MM/dd/yyyy", t = (K) => Oa(K, e.enableSeconds), r = () => e.range ? e.startTime && Array.isArray(e.startTime) ? [t(e.startTime[0]), t(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? t(e.startTime) : null, l = W(() => Gr(e.multiCalendars)), c = W(() => r()), b = W(() => Kr(e.ariaLabels)), k = W(() => Xr(e.filters)), P = W(() => Qr(e.transitions)), g = W(() => Jr(e.actionRow)), S = W(
    () => Zr(e.previewFormat, e.format, a())
  ), Y = W(() => qr(e.textInput)), G = W(() => xr(e.inline)), N = W(() => el(e.config));
  return {
    defaultedTransitions: P,
    defaultedMultiCalendars: l,
    defaultedStartTime: c,
    defaultedAriaLabels: b,
    defaultedFilters: k,
    defaultedActionRow: g,
    defaultedPreviewFormat: S,
    defaultedTextInput: Y,
    defaultedInline: G,
    defaultedConfig: N,
    getDefaultPattern: a,
    getDefaultStartTime: r
  };
}, tl = (e, n, a) => {
  const t = X(), { defaultedTextInput: r, getDefaultPattern: l } = Ae(n), c = X(""), b = Qt(n, "format");
  yt(t, () => {
    e("internal-model-change", t.value);
  }), yt(b, () => {
    v();
  });
  const k = (s) => Ra(s, n.timezone), P = (s) => Ue(s, n.timezone), g = (s, I, pe = !1) => Ia(
    s,
    n.format,
    n.formatLocale,
    r.value.rangeSeparator,
    n.modelAuto,
    I ?? l(),
    pe
  ), S = (s) => s ? n.modelType ? M(s) : {
    hours: Qe(s),
    minutes: Je(s),
    seconds: n.enableSeconds ? wt(s) : 0
  } : null, Y = (s) => n.modelType ? M(s) : { month: me(s), year: ge(s) }, G = (s) => Array.isArray(s) ? zt(
    () => [
      ft(H(), s[0]),
      s[1] ? ft(H(), s[1]) : pt(n.partialRange)
    ],
    n.range
  ) : ft(H(), +s), N = (s, I) => (typeof s == "string" || typeof s == "number") && n.modelType ? E(s) : I, K = (s) => Array.isArray(s) ? [
    N(
      s[0],
      ot(null, +s[0].hours, +s[0].minutes, s[0].seconds)
    ),
    N(
      s[1],
      ot(null, +s[1].hours, +s[1].minutes, s[1].seconds)
    )
  ] : N(s, ot(null, s.hours, s.minutes, s.seconds)), J = (s) => Array.isArray(s) ? n.multiDates ? s.map((I) => N(I, xe(null, +I.month, +I.year))) : zt(
    () => [
      N(s[0], xe(null, +s[0].month, +s[0].year)),
      N(
        s[1],
        s[1] ? xe(null, +s[1].month, +s[1].year) : pt(n.partialRange)
      )
    ],
    n.range
  ) : N(s, xe(null, +s.month, +s.year)), h = (s) => {
    if (Array.isArray(s))
      return s.map((I) => E(I));
    throw new Error(qt.dateArr("multi-dates"));
  }, O = (s) => {
    if (Array.isArray(s))
      return [H(s[0]), H(s[1])];
    throw new Error(qt.dateArr("week-picker"));
  }, p = (s) => n.modelAuto ? Array.isArray(s) ? [E(s[0]), E(s[1])] : n.autoApply ? [E(s)] : [E(s), null] : Array.isArray(s) ? zt(
    () => [
      E(s[0]),
      s[1] ? E(s[1]) : pt(n.partialRange)
    ],
    n.range
  ) : E(s), m = () => {
    Array.isArray(t.value) && n.range && t.value.length === 1 && t.value.push(pt(n.partialRange));
  }, C = () => {
    const s = t.value;
    return [
      M(s[0]),
      s[1] ? M(s[1]) : pt(n.partialRange)
    ];
  }, j = () => t.value[1] ? C() : M(Te(t.value[0])), re = () => (t.value || []).map((s) => M(s)), ue = () => (m(), n.modelAuto ? j() : n.multiDates ? re() : Array.isArray(t.value) ? zt(() => C(), n.range) : M(Te(t.value))), Q = (s) => !s || Array.isArray(s) && !s.length ? null : n.timePicker ? K(Te(s)) : n.monthPicker ? J(Te(s)) : n.yearPicker ? G(Te(s)) : n.multiDates ? h(Te(s)) : n.weekPicker ? O(Te(s)) : p(Te(s)), y = (s) => {
    const I = Q(s);
    On(Te(I)) ? (t.value = Te(I), v()) : (t.value = null, c.value = "");
  }, w = () => {
    const s = (I) => rt(I, r.value.format);
    return `${s(t.value[0])} ${r.value.rangeSeparator} ${t.value[1] ? s(t.value[1]) : ""}`;
  }, L = () => a.value && t.value ? Array.isArray(t.value) ? w() : rt(t.value, r.value.format) : g(t.value), x = () => t.value ? n.multiDates ? t.value.map((s) => g(s)).join("; ") : r.value.enabled && typeof r.value.format == "string" ? L() : g(t.value) : "", v = () => {
    !n.format || typeof n.format == "string" || r.value.enabled && typeof r.value.format == "string" ? c.value = x() : c.value = n.format(t.value);
  }, E = (s) => {
    if (n.utc) {
      const I = new Date(s);
      return n.utc === "preserve" ? new Date(I.getTime() + I.getTimezoneOffset() * 6e4) : I;
    }
    return n.modelType ? n.modelType === "date" || n.modelType === "timestamp" ? P(new Date(s)) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? An(s, l(), /* @__PURE__ */ new Date()) : P(An(s, n.modelType, /* @__PURE__ */ new Date())) : P(new Date(s));
  }, M = (s) => s ? n.utc ? Vr(s, n.utc === "preserve", n.enableSeconds) : n.modelType ? n.modelType === "timestamp" ? +k(s) : n.modelType === "format" && (typeof n.format == "string" || !n.format) ? g(k(s)) : g(k(s), n.modelType, !0) : k(s) : "", A = (s, I = !1) => {
    if (e("update:model-value", s), n.emitTimezone && I) {
      const pe = Array.isArray(s) ? s.map((u) => Ue(Te(u)), n.emitTimezone) : Ue(Te(s), n.emitTimezone);
      e("update:model-timezone-value", pe);
    }
  }, i = (s) => Array.isArray(t.value) ? n.multiDates ? t.value.map((I) => s(I)) : [
    s(t.value[0]),
    t.value[1] ? s(t.value[1]) : pt(n.partialRange)
  ] : s(Te(t.value)), o = (s) => A(Te(i(s)));
  return {
    inputValue: c,
    internalModelValue: t,
    checkBeforeEmit: () => t.value ? n.range ? n.partialRange ? t.value.length >= 1 : t.value.length === 2 : !!t.value : !1,
    parseExternalModelValue: y,
    formatInputValue: v,
    emitModelValue: () => (v(), n.monthPicker ? o(Y) : n.timePicker ? o(S) : n.yearPicker ? o(ge) : n.weekPicker ? A(
      t.value.map((s) => M(s)),
      !0
    ) : A(ue(), !0))
  };
}, nl = (e, n) => {
  const { defaultedFilters: a } = Ae(e), { validateMonthYearInRange: t } = Tt(e), r = (P, g) => {
    let S = P;
    return a.value.months.includes(me(S)) ? (S = g ? vt(P, 1) : Ot(P, 1), r(S, g)) : S;
  }, l = (P, g) => {
    let S = P;
    return a.value.years.includes(ge(S)) ? (S = g ? ka(P, 1) : wa(P, 1), l(S, g)) : S;
  }, c = (P, g = !1) => {
    const S = we(/* @__PURE__ */ new Date(), { month: e.month, year: e.year });
    let Y = P ? vt(S, 1) : Ot(S, 1);
    e.disableYearSelect && (Y = ft(Y, e.year));
    let G = me(Y), N = ge(Y);
    a.value.months.includes(G) && (Y = r(Y, P), G = me(Y), N = ge(Y)), a.value.years.includes(N) && (Y = l(Y, P), N = ge(Y)), t(G, N, P, e.preventMinMaxNavigation) && b(G, N, g);
  }, b = (P, g, S) => {
    n("update-month-year", { month: P, year: g, fromNav: S });
  }, k = W(() => (P) => Na(
    we(/* @__PURE__ */ new Date(), { month: e.month, year: e.year }),
    e.maxDate,
    e.minDate,
    e.preventMinMaxNavigation,
    P
  ));
  return { handleMonthYearChange: c, isDisabled: k, updateMonthYear: b };
};
var bt = /* @__PURE__ */ ((e) => (e.center = "center", e.left = "left", e.right = "right", e))(bt || {}), Ke = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e))(Ke || {}), dt = /* @__PURE__ */ ((e) => (e.top = "top", e.bottom = "bottom", e))(dt || {}), gt = /* @__PURE__ */ ((e) => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(gt || {}), Xe = /* @__PURE__ */ ((e) => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(Xe || {});
const al = ({
  menuRef: e,
  menuRefInner: n,
  inputRef: a,
  pickerWrapperRef: t,
  inline: r,
  emit: l,
  props: c,
  slots: b
}) => {
  const k = X({}), P = X(!1), g = X({
    top: "0",
    left: "0"
  }), S = X(!1), Y = Qt(c, "teleportCenter");
  yt(Y, () => {
    g.value = JSON.parse(JSON.stringify({})), m();
  });
  const G = (M) => {
    if (c.teleport) {
      const A = M.getBoundingClientRect();
      return {
        left: A.left + window.scrollX,
        top: A.top + window.scrollY
      };
    }
    return { top: 0, left: 0 };
  }, N = (M, A) => {
    g.value.left = `${M + A - k.value.width}px`;
  }, K = (M) => {
    g.value.left = `${M}px`;
  }, J = (M, A) => {
    c.position === bt.left && K(M), c.position === bt.right && N(M, A), c.position === bt.center && (g.value.left = `${M + A / 2 - k.value.width / 2}px`);
  }, h = (M) => {
    const { width: A, height: i } = M.getBoundingClientRect(), { top: o, left: $ } = c.altPosition ? c.altPosition(M) : G(M);
    return { top: +o, left: +$, width: A, height: i };
  }, O = () => {
    g.value.left = "50%", g.value.top = "50%", g.value.transform = "translate(-50%, -50%)", g.value.position = "fixed", delete g.value.opacity;
  }, p = () => {
    const M = Se(a), { top: A, left: i, transform: o } = c.altPosition(M);
    g.value = { top: `${A}px`, left: `${i}px`, transform: o ?? "" };
  }, m = (M = !0) => {
    var A;
    if (!r.value.enabled) {
      if (Y.value)
        return O();
      if (c.altPosition !== null)
        return p();
      if (M) {
        const i = c.teleport ? (A = n.value) == null ? void 0 : A.$el : e.value;
        i && (k.value = i.getBoundingClientRect()), l("recalculate-position");
      }
      return w();
    }
  }, C = ({ inputEl: M, left: A, width: i }) => {
    window.screen.width > 768 && !P.value && J(A, i), ue(M);
  }, j = (M) => {
    const { top: A, left: i, height: o, width: $ } = h(M);
    g.value.top = `${o + A + +c.offset}px`, S.value = !1, P.value || (g.value.left = `${i + $ / 2 - k.value.width / 2}px`), C({ inputEl: M, left: i, width: $ });
  }, re = (M) => {
    const { top: A, left: i, width: o } = h(M);
    g.value.top = `${A - +c.offset - k.value.height}px`, S.value = !0, C({ inputEl: M, left: i, width: o });
  }, ue = (M) => {
    if (c.autoPosition) {
      const { left: A, width: i } = h(M), { left: o, right: $ } = k.value;
      if (!P.value) {
        if (Math.abs(o) !== Math.abs($)) {
          if (o <= 0)
            return P.value = !0, K(A);
          if ($ >= document.documentElement.clientWidth)
            return P.value = !0, N(A, i);
        }
        return J(A, i);
      }
    }
  }, Q = () => {
    const M = Se(a);
    if (M) {
      const { height: A } = k.value, { top: i, height: o } = M.getBoundingClientRect(), Z = window.innerHeight - i - o, s = i;
      return A <= Z ? dt.bottom : A > Z && A <= s ? dt.top : Z >= s ? dt.bottom : dt.top;
    }
    return dt.bottom;
  }, y = (M) => Q() === dt.bottom ? j(M) : re(M), w = () => {
    const M = Se(a);
    if (M)
      return c.autoPosition ? y(M) : j(M);
  }, L = function(M) {
    if (M) {
      const A = M.scrollHeight > M.clientHeight, o = window.getComputedStyle(M).overflowY.indexOf("hidden") !== -1;
      return A && !o;
    }
    return !0;
  }, x = function(M) {
    return !M || M === document.body || M.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : L(M) ? M : x(M.parentNode);
  }, v = (M) => {
    if (M)
      switch (c.position) {
        case bt.left:
          return { left: 0, transform: "translateX(0)" };
        case bt.right:
          return { left: `${M.width}px`, transform: "translateX(-100%)" };
        default:
          return { left: `${M.width / 2}px`, transform: "translateX(-50%)" };
      }
    return {};
  };
  return {
    openOnTop: S,
    menuStyle: g,
    xCorrect: P,
    setMenuPosition: m,
    getScrollableParent: x,
    shadowRender: (M, A) => {
      var pe, u, B;
      const i = document.createElement("div"), o = (pe = Se(a)) == null ? void 0 : pe.getBoundingClientRect();
      i.setAttribute("id", "dp--temp-container");
      const $ = (u = t.value) != null && u.clientWidth ? t.value : document.body;
      $.append(i);
      const Z = document.getElementById("dp--temp-container"), s = v(o), I = za(
        M,
        {
          ...A,
          shadow: !0,
          style: { opacity: 0, position: "absolute", ...s }
        },
        Object.fromEntries(
          Object.keys(b).filter((U) => ["right-sidebar", "left-sidebar"].includes(U)).map((U) => [U, b[U]])
        )
      );
      Zn(I, Z), k.value = (B = I.el) == null ? void 0 : B.getBoundingClientRect(), Zn(null, Z), $.removeChild(Z);
    }
  };
}, nt = [
  { name: "clock-icon", use: ["time", "calendar", "shared"] },
  { name: "arrow-left", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-right", use: ["month-year", "calendar", "shared", "year-mode"] },
  { name: "arrow-up", use: ["time", "calendar", "month-year", "shared"] },
  { name: "arrow-down", use: ["time", "calendar", "month-year", "shared"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar", "shared", "year-mode"] },
  { name: "day", use: ["calendar", "shared"] },
  { name: "month-overlay-value", use: ["calendar", "month-year", "shared"] },
  { name: "year-overlay-value", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "year-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay", use: ["month-year", "shared"] },
  { name: "month-overlay-header", use: ["month-year", "shared"] },
  { name: "year-overlay-header", use: ["month-year", "shared"] },
  { name: "hours-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "minutes-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "seconds-overlay-value", use: ["calendar", "time", "shared"] },
  { name: "hours", use: ["calendar", "time", "shared"] },
  { name: "minutes", use: ["calendar", "time", "shared"] },
  { name: "month", use: ["calendar", "month-year", "shared"] },
  { name: "year", use: ["calendar", "month-year", "shared", "year-mode"] },
  { name: "action-buttons", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar", "shared"] },
  { name: "marker-tooltip", use: ["calendar", "shared"] },
  { name: "action-extra", use: ["menu"] },
  { name: "time-picker-overlay", use: ["calendar", "time", "shared"] },
  { name: "am-pm-button", use: ["calendar", "time", "shared"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year", "shared"] },
  { name: "time-picker", use: ["menu", "shared"] },
  { name: "action-row", use: ["action"] },
  { name: "marker", use: ["calendar", "shared"] },
  { name: "quarter", use: ["shared"] }
], rl = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], ll = {
  all: () => nt,
  monthYear: () => nt.filter((e) => e.use.includes("month-year")),
  input: () => rl,
  timePicker: () => nt.filter((e) => e.use.includes("time")),
  action: () => nt.filter((e) => e.use.includes("action")),
  calendar: () => nt.filter((e) => e.use.includes("calendar")),
  menu: () => nt.filter((e) => e.use.includes("menu")),
  shared: () => nt.filter((e) => e.use.includes("shared")),
  yearMode: () => nt.filter((e) => e.use.includes("year-mode"))
}, Ve = (e, n, a) => {
  const t = [];
  return ll[n]().forEach((r) => {
    e[r.name] && t.push(r.name);
  }), a != null && a.length && a.forEach((r) => {
    r.slot && t.push(r.slot);
  }), t;
}, Et = (e) => {
  const n = W(() => (t) => e.value ? t ? e.value.open : e.value.close : ""), a = W(() => (t) => e.value ? t ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
  return { transitionName: n, showTransition: !!e.value, menuTransition: a };
}, Ft = (e, n) => {
  const a = H(Ue(/* @__PURE__ */ new Date(), e.timezone)), t = X([{ month: me(a), year: ge(a) }]), r = It({
    hours: e.range ? [Qe(a), Qe(a)] : Qe(a),
    minutes: e.range ? [Je(a), Je(a)] : Je(a),
    seconds: e.range ? [0, 0] : 0
  }), l = W({
    get: () => e.internalModelValue,
    set: (k) => {
      !e.readonly && !e.disabled && n("update:internal-model-value", k);
    }
  }), c = W(
    () => (k) => t.value[k] ? t.value[k].month : 0
  ), b = W(
    () => (k) => t.value[k] ? t.value[k].year : 0
  );
  return {
    calendars: t,
    time: r,
    modelValue: l,
    month: c,
    year: b
  };
}, ol = (e, n) => {
  const { defaultedMultiCalendars: a } = Ae(n), { isDisabled: t, matchDate: r } = Tt(n), l = X(null), c = X(H(Ue(/* @__PURE__ */ new Date(), n.timezone))), b = (o) => {
    !o.current && n.hideOffsetDates || (l.value = o.value);
  }, k = () => {
    l.value = null;
  }, P = (o) => Array.isArray(e.value) && n.range && e.value[0] && l.value ? o ? Ie(l.value, e.value[0]) : Re(l.value, e.value[0]) : !0, g = (o, $) => {
    const Z = () => e.value ? $ ? e.value[0] || null : e.value[1] : null, s = e.value && Array.isArray(e.value) ? Z() : null;
    return ye(H(o.value), s);
  }, S = (o) => {
    const $ = Array.isArray(e.value) ? e.value[0] : null;
    return o ? !Re(l.value ?? null, $) : !0;
  }, Y = (o, $ = !0) => (n.range || n.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? n.hideOffsetDates && !o.current ? !1 : ye(H(o.value), e.value[$ ? 0 : 1]) : n.range ? g(o, $) && S($) || ye(o.value, Array.isArray(e.value) ? e.value[0] : null) && P($) : !1, G = (o, $, Z) => Array.isArray(e.value) && e.value[0] && e.value.length === 1 ? o ? !1 : Z ? Ie(e.value[0], $.value) : Re(e.value[0], $.value) : !1, N = (o) => !e.value || n.hideOffsetDates && !o.current ? !1 : n.range ? n.modelAuto && Array.isArray(e.value) ? ye(o.value, e.value[0] ? e.value[0] : c.value) : !1 : n.multiDates && Array.isArray(e.value) ? e.value.some(($) => ye($, o.value)) : ye(o.value, e.value ? e.value : c.value), K = (o) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !o.current)
          return !1;
        const $ = ct(l.value, +n.autoRange), Z = Zt(H(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye(Z[1], H(o.value)) : ye($, H(o.value));
      }
      return !1;
    }
    return !1;
  }, J = (o) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        const $ = ct(l.value, +n.autoRange);
        if (n.hideOffsetDates && !o.current)
          return !1;
        const Z = Zt(H(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? Ie(o.value, Z[0]) && Re(o.value, Z[1]) : Ie(o.value, l.value) && Re(o.value, $);
      }
      return !1;
    }
    return !1;
  }, h = (o) => {
    if (n.autoRange || n.weekPicker) {
      if (l.value) {
        if (n.hideOffsetDates && !o.current)
          return !1;
        const $ = Zt(H(l.value), n.timezone, n.weekStart);
        return n.weekPicker ? ye($[0], o.value) : ye(l.value, o.value);
      }
      return !1;
    }
    return !1;
  }, O = (o) => Xt(e.value, l.value, o.value), p = () => n.modelAuto && Array.isArray(n.internalModelValue) ? !!n.internalModelValue[0] : !1, m = () => n.modelAuto ? Pa(n.internalModelValue) : !0, C = (o) => {
    if (Array.isArray(e.value) && e.value.length || n.weekPicker)
      return !1;
    const $ = n.range ? !Y(o) && !Y(o, !1) : !0;
    return !t(o.value) && !N(o) && !(!o.current && n.hideOffsetDates) && $;
  }, j = (o) => n.range ? n.modelAuto ? p() && N(o) : !1 : N(o), re = (o) => {
    var $;
    return n.highlight ? r(
      o.value,
      ($ = n.arrMapValues) != null && $.highlightedDates ? n.arrMapValues.highlightedDates : n.highlight
    ) : !1;
  }, ue = (o) => t(o.value) && n.highlightDisabledDays === !1, Q = (o) => {
    var $;
    return ($ = n.highlightWeekDays) == null ? void 0 : $.includes(o.value.getDay());
  }, y = (o) => (n.range || n.weekPicker) && (!(a.value.count > 0) || o.current) && m() && !(!o.current && n.hideOffsetDates) && !N(o) ? O(o) : !1, w = (o) => {
    const { isRangeStart: $, isRangeEnd: Z } = v(o), s = n.range ? $ || Z : !1;
    return {
      dp__cell_offset: !o.current,
      dp__pointer: !n.disabled && !(!o.current && n.hideOffsetDates) && !t(o.value),
      dp__cell_disabled: t(o.value),
      dp__cell_highlight: !ue(o) && (re(o) || Q(o)) && !j(o) && !s,
      dp__cell_highlight_active: !ue(o) && (re(o) || Q(o)) && j(o),
      dp__today: !n.noToday && ye(o.value, c.value) && o.current
    };
  }, L = (o) => ({
    dp__active_date: j(o),
    dp__date_hover: C(o)
  }), x = (o) => ({
    ...E(o),
    ...M(o),
    dp__range_between_week: y(o) && n.weekPicker
  }), v = (o) => {
    const $ = a.value.count > 0 ? o.current && Y(o) && m() : Y(o) && m(), Z = a.value.count > 0 ? o.current && Y(o, !1) && m() : Y(o, !1) && m();
    return { isRangeStart: $, isRangeEnd: Z };
  }, E = (o) => {
    const { isRangeStart: $, isRangeEnd: Z } = v(o);
    return {
      dp__range_start: $,
      dp__range_end: Z,
      dp__range_between: y(o) && !n.weekPicker,
      dp__date_hover_start: G(C(o), o, !0),
      dp__date_hover_end: G(C(o), o, !1)
    };
  }, M = (o) => ({
    ...E(o),
    dp__cell_auto_range: J(o),
    dp__cell_auto_range_start: h(o),
    dp__cell_auto_range_end: K(o)
  }), A = (o) => n.range ? n.autoRange ? M(o) : n.modelAuto ? { ...L(o), ...E(o) } : E(o) : n.weekPicker ? x(o) : L(o);
  return {
    setHoverDate: b,
    clearHoverDate: k,
    getDayClassData: (o) => n.hideOffsetDates && !o.current ? {} : {
      ...w(o),
      ...A(o),
      [n.dayClass ? n.dayClass(o.value) : ""]: !0,
      [n.calendarCellClassName]: !!n.calendarCellClassName
    }
  };
}, Tt = (e) => {
  const { defaultedFilters: n } = Ae(e), a = () => {
    if (e.timezone)
      return e.timezone;
    if (e.utc)
      return "UTC";
  }, t = (y) => {
    const w = We(r(H(y))).toISOString(), [L] = w.split("T");
    return L;
  }, r = (y) => e.utc === "preserve" ? Ra(y, a()) : Ue(y, a()), l = (y) => {
    var $;
    const w = e.maxDate ? Ie(r(y), r(H(e.maxDate))) : !1, L = e.minDate ? Re(r(y), r(H(e.minDate))) : !1, x = P(
      r(y),
      ($ = e.arrMapValues) != null && $.disabledDates ? e.arrMapValues.disabledDates : e.disabledDates
    ), E = n.value.months.map((Z) => +Z).includes(me(y)), M = e.disabledWeekDays.length ? e.disabledWeekDays.some((Z) => +Z === Ja(y)) : !1, A = S(y), i = ge(y), o = i < +e.yearRange[0] || i > +e.yearRange[1];
    return !(w || L || x || E || o || M || A);
  }, c = (y, w) => Re(...at(e.minDate, y, w)) || ye(...at(e.minDate, y, w)), b = (y, w) => Ie(...at(e.maxDate, y, w)) || ye(...at(e.maxDate, y, w)), k = (y, w, L) => {
    let x = !1;
    return e.maxDate && L && b(y, w) && (x = !0), e.minDate && !L && c(y, w) && (x = !0), x;
  }, P = (y, w) => y ? w instanceof Map ? !!w.get(t(y)) : Array.isArray(w) ? w.some((L) => ye(r(H(L)), r(y))) : w ? w(H(JSON.parse(JSON.stringify(y)))) : !1 : !0, g = (y, w, L, x) => {
    let v = !1;
    return x ? e.minDate && e.maxDate ? v = k(y, w, L) : (e.minDate && c(y, w) || e.maxDate && b(y, w)) && (v = !0) : v = !0, v;
  }, S = (y) => {
    var w, L, x, v, E;
    return Array.isArray(e.allowedDates) && !((w = e.allowedDates) != null && w.length) ? !0 : (L = e.arrMapValues) != null && L.allowedDates ? !P(y, (x = e.arrMapValues) == null ? void 0 : x.allowedDates) : (v = e.allowedDates) != null && v.length ? !((E = e.allowedDates) != null && E.some((M) => ye(r(H(M)), r(y)))) : !1;
  }, Y = (y) => !l(y), G = (y) => e.noDisabledRange ? !pa({ start: y[0], end: y[1] }).some((L) => Y(L)) : !0, N = (y, w, L = 0) => {
    if (Array.isArray(w) && w[L]) {
      const x = xa(y, w[L]), v = Ya(w[L], y), E = v.length === 1 ? 0 : v.filter((A) => Y(A)).length, M = Math.abs(x) - E;
      if (e.minRange && e.maxRange)
        return M >= +e.minRange && M <= +e.maxRange;
      if (e.minRange)
        return M >= +e.minRange;
      if (e.maxRange)
        return M <= +e.maxRange;
    }
    return !0;
  }, K = (y) => new Map(y.map((w) => [t(w), !0])), J = (y) => Array.isArray(y) && y.length > 0, h = () => {
    const y = {
      disabledDates: null,
      allowedDates: null,
      highlightedDates: null
    };
    return J(e.allowedDates) && (y.allowedDates = K(e.allowedDates)), J(e.highlight) && (y.highlightedDates = K(e.highlight)), J(e.disabledDates) && (y.disabledDates = K(e.disabledDates)), y;
  }, O = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, p = (y) => Array.isArray(y) ? [y[0] ? kn(y[0]) : null, y[1] ? kn(y[1]) : null] : kn(y), m = (y, w, L) => y.find(
    (x) => +x.hours === Qe(w) && x.minutes === "*" ? !0 : +x.minutes === Je(w) && +x.hours === Qe(w)
  ) && L, C = (y, w, L) => {
    const [x, v] = y, [E, M] = w;
    return !m(x, E, L) && !m(v, M, L) && L;
  }, j = (y, w) => {
    const L = Array.isArray(w) ? w : [w];
    return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? C(e.disabledTimes, L, y) : !L.some((x) => m(e.disabledTimes, x, y)) : y;
  }, re = (y, w) => {
    const L = Array.isArray(w) ? [mt(w[0]), w[1] ? mt(w[1]) : void 0] : mt(w), x = !e.disabledTimes(L);
    return y && x;
  }, ue = (y, w) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? j(w, y) : re(w, y) : w;
  return {
    isDisabled: Y,
    validateDate: l,
    validateMonthYearInRange: g,
    isDateRangeAllowed: G,
    checkMinMaxRange: N,
    matchDate: P,
    mapDatesArrToMap: h,
    isValidTime: (y) => {
      let w = !0;
      if (!y || O())
        return !0;
      const L = !e.minDate && !e.maxDate ? p(y) : y;
      return (e.maxTime || e.maxDate) && (w = ca(e.maxTime, e.maxDate, "max", Te(L), w)), (e.minTime || e.minDate) && (w = ca(e.minTime, e.minDate, "min", Te(L), w)), ue(y, w);
    }
  };
}, Jt = () => {
  const e = W(() => (t, r) => t == null ? void 0 : t.includes(r)), n = W(() => (t, r) => t.count ? t.solo ? !0 : r === 0 : !0), a = W(() => (t, r) => t.count ? t.solo ? !0 : r === t.count - 1 : !0);
  return { hideNavigationButtons: e, showLeftIcon: n, showRightIcon: a };
}, sl = (e, n, a) => {
  const t = X(0), r = It({
    // monthYearInput: !!props.timePicker,
    [gt.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
    [gt.calendar]: !1,
    [gt.header]: !1
  }), l = (g) => {
    var S;
    (S = e.flow) != null && S.length && (r[g] = !0, Object.keys(r).filter((Y) => !r[Y]).length || P());
  }, c = () => {
    var g;
    (g = e.flow) != null && g.length && t.value !== -1 && (t.value += 1, n("flow-step", t.value), P());
  }, b = () => {
    t.value = -1;
  }, k = (g, S, ...Y) => {
    e.flow[t.value] === g && a.value && a.value[S](...Y);
  }, P = () => {
    k(Xe.month, "toggleMonthPicker", !0), k(Xe.year, "toggleYearPicker", !0), k(Xe.calendar, "toggleTimePicker", !1, !0), k(Xe.time, "toggleTimePicker", !0, !0);
    const g = e.flow[t.value];
    (g === Xe.hours || g === Xe.minutes || g === Xe.seconds) && k(g, "toggleTimePicker", !0, !0, g);
  };
  return { childMount: l, updateFlowStep: c, resetFlow: b, flowStep: t };
}, xt = {
  multiCalendars: { type: [Boolean, Number, String, Object], default: void 0 },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: !1 },
  format: {
    type: [String, Function],
    default: () => null
  },
  autoPosition: { type: Boolean, default: !0 },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: !0 },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: !1 },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  emitTimezone: { type: String, default: null },
  vertical: { type: Boolean, default: !1 },
  disableMonthYearSelect: { type: Boolean, default: !1 },
  disableYearSelect: { type: Boolean, default: !1 },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: !0 },
  autoApply: { type: Boolean, default: !1 },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: !1 },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: !1 },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: null },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  escClose: { type: Boolean, default: !0 },
  spaceConfirm: { type: Boolean, default: !0 },
  monthChangeOnArrows: { type: Boolean, default: !0 },
  presetDates: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  partialFlow: { type: Boolean, default: !1 },
  preventMinMaxNavigation: { type: Boolean, default: !1 },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: !1 },
  weekPicker: { type: Boolean, default: !1 },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: !1 },
  disableTimeRangeValidation: { type: Boolean, default: !1 },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: !1 },
  teleport: { type: [String, Boolean], default: null },
  teleportCenter: { type: Boolean, default: !1 },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  monthChangeOnScroll: { type: [Boolean, String], default: !0 },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: !1 },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: !1 },
  modelAuto: { type: Boolean, default: !1 },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: !1 },
  partialRange: { type: Boolean, default: !0 },
  ignoreTimeValidation: { type: Boolean, default: !1 },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: !1 },
  clearable: { type: Boolean, default: !0 },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: !1 },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  fixedStart: { type: Boolean, default: !1 },
  fixedEnd: { type: Boolean, default: !1 },
  timePicker: { type: Boolean, default: !1 },
  enableSeconds: { type: Boolean, default: !1 },
  is24: { type: Boolean, default: !0 },
  noHoursOverlay: { type: Boolean, default: !1 },
  noMinutesOverlay: { type: Boolean, default: !1 },
  noSecondsOverlay: { type: Boolean, default: !1 },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: !1 },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: !1 },
  readonly: { type: Boolean, default: !1 },
  inline: { type: [Boolean, Object], default: !1 },
  textInput: { type: [Boolean, Object], default: !1 },
  noDisabledRange: { type: Boolean, default: !1 },
  sixWeeks: { type: [Boolean, String], default: !1 },
  actionRow: { type: Object, default: () => ({}) },
  focusStartDate: { type: Boolean, default: !1 },
  disabledTimes: { type: [Function, Array], default: void 0 },
  showLastInRange: { type: Boolean, default: !0 },
  timePickerInline: { type: Boolean, default: !1 },
  calendar: { type: Function, default: null },
  config: { type: Object, default: void 0 },
  quarterPicker: { type: Boolean, default: !1 }
}, qe = {
  ...xt,
  shadow: { type: Boolean, default: !1 },
  flowStep: { type: Number, default: 0 },
  internalModelValue: { type: [Date, Array], default: null },
  arrMapValues: { type: Object, default: () => ({}) }
}, il = {
  key: 1,
  class: "dp__input_wrap"
}, ul = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-label", "aria-disabled", "aria-invalid", "onKeydown"], dl = {
  key: 2,
  class: "dp__clear_icon"
}, cl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: !1 },
    inputValue: { type: String, default: "" },
    ...xt
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur",
    "real-blur"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, {
      defaultedTextInput: r,
      defaultedAriaLabels: l,
      defaultedInline: c,
      defaultedConfig: b,
      getDefaultPattern: k,
      getDefaultStartTime: P
    } = Ae(t), g = X(), S = X(null), Y = X(!1), G = X(!1), N = W(
      () => ({
        dp__pointer: !t.disabled && !t.readonly && !r.value.enabled,
        dp__disabled: t.disabled,
        dp__input_readonly: !r.value.enabled,
        dp__input: !0,
        dp__input_icon_pad: !t.hideInputIcon,
        dp__input_valid: !!t.state,
        dp__input_invalid: t.state === !1,
        dp__input_focus: Y.value || t.isMenuOpen,
        dp__input_reg: !r.value.enabled,
        [t.inputClassName]: !!t.inputClassName
      })
    ), K = () => {
      a("set-input-date", null), t.autoApply && (a("set-empty-date"), g.value = null);
    }, J = (v) => {
      const E = P();
      return Hr(
        v,
        r.value.format ?? k(),
        E ?? Oa({}, t.enableSeconds),
        t.inputValue,
        G.value
      );
    }, h = (v) => {
      const { rangeSeparator: E } = r.value, [M, A] = v.split(`${E}`);
      if (M) {
        const i = J(M.trim()), o = A ? J(A.trim()) : null, $ = i && o ? [i, o] : [i];
        g.value = i ? $ : null;
      }
    }, O = () => {
      G.value = !0;
    }, p = (v) => {
      if (t.range)
        h(v);
      else if (t.multiDates) {
        const E = v.split(";");
        g.value = E.map((M) => J(M.trim())).filter((M) => M);
      } else
        g.value = J(v);
    }, m = (v) => {
      var M;
      const E = typeof v == "string" ? v : (M = v.target) == null ? void 0 : M.value;
      E !== "" ? (r.value.openMenu && !t.isMenuOpen && a("open"), p(E), a("set-input-date", g.value)) : K(), G.value = !1, a("update:input-value", E);
    }, C = (v) => {
      r.value.enabled ? (p(v.target.value), r.value.enterSubmit && On(g.value) && t.inputValue !== "" ? (a("set-input-date", g.value, !0), g.value = null) : r.value.enterSubmit && t.inputValue === "" && (g.value = null, a("clear"))) : ue(v);
    }, j = (v) => {
      r.value.enabled && r.value.tabSubmit && p(v.target.value), r.value.tabSubmit && On(g.value) && t.inputValue !== "" ? (a("set-input-date", g.value, !0), g.value = null) : r.value.tabSubmit && t.inputValue === "" && (g.value = null, a("clear"));
    }, re = () => {
      var v;
      Y.value = !0, a("focus"), r.value.enabled && r.value.selectOnFocus && ((v = S.value) == null || v.select());
    }, ue = (v) => {
      v.preventDefault(), lt(v, b.value, !0), r.value.enabled && r.value.openMenu && !c.value.input && !t.isMenuOpen ? a("open") : r.value.enabled || a("toggle");
    }, Q = () => {
      a("real-blur"), Y.value = !1, (!t.isMenuOpen || c.value.enabled && c.value.input) && a("blur"), t.autoApply && r.value.enabled && g.value && !t.isMenuOpen && (a("set-input-date", g.value), a("select-date"), g.value = null);
    }, y = (v) => {
      lt(v, b.value, !0), a("clear");
    }, w = (v) => {
      if (!r.value.enabled) {
        if (v.code === "Tab")
          return;
        v.preventDefault();
      }
    };
    return n({
      focusInput: () => {
        var v;
        (v = S.value) == null || v.focus({ preventScroll: !0 });
      },
      setParsedDate: (v) => {
        g.value = v;
      }
    }), (v, E) => {
      var M;
      return D(), V("div", { onClick: ue }, [
        v.$slots.trigger && !v.$slots["dp-input"] && !f(c).enabled ? te(v.$slots, "trigger", { key: 0 }) : z("", !0),
        !v.$slots.trigger && (!f(c).enabled || f(c).input) ? (D(), V("div", il, [
          v.$slots["dp-input"] && !v.$slots.trigger && !f(c).enabled ? te(v.$slots, "dp-input", {
            key: 0,
            value: e.inputValue,
            isMenuOpen: e.isMenuOpen,
            onInput: m,
            onEnter: C,
            onTab: j,
            onClear: y,
            onBlur: Q,
            onKeypress: w,
            onPaste: O
          }) : z("", !0),
          v.$slots["dp-input"] ? z("", !0) : (D(), V("input", {
            key: 1,
            ref_key: "inputRef",
            ref: S,
            id: v.uid ? `dp-input-${v.uid}` : void 0,
            name: v.name,
            class: he(N.value),
            inputmode: f(r).enabled ? "text" : "none",
            placeholder: v.placeholder,
            disabled: v.disabled,
            readonly: v.readonly,
            required: v.required,
            value: e.inputValue,
            autocomplete: v.autocomplete,
            "aria-label": (M = f(l)) == null ? void 0 : M.input,
            "aria-disabled": v.disabled || void 0,
            "aria-invalid": v.state === !1 ? !0 : void 0,
            onInput: m,
            onKeydown: [
              le(C, ["enter"]),
              le(j, ["tab"]),
              w
            ],
            onBlur: Q,
            onFocus: re,
            onKeypress: w,
            onPaste: O
          }, null, 42, ul)),
          oe("div", {
            onClick: E[2] || (E[2] = (A) => a("toggle"))
          }, [
            v.$slots["input-icon"] && !v.hideInputIcon ? (D(), V("span", {
              key: 0,
              class: "dp__input_icon",
              onClick: E[0] || (E[0] = (A) => a("toggle"))
            }, [
              te(v.$slots, "input-icon")
            ])) : z("", !0),
            !v.$slots["input-icon"] && !v.hideInputIcon && !v.$slots["dp-input"] ? (D(), ve(f(Bt), {
              key: 1,
              onClick: E[1] || (E[1] = (A) => a("toggle")),
              class: "dp__input_icon dp__input_icons"
            })) : z("", !0)
          ]),
          v.$slots["clear-icon"] && e.inputValue && v.clearable && !v.disabled && !v.readonly ? (D(), V("span", dl, [
            te(v.$slots, "clear-icon", { clear: y })
          ])) : z("", !0),
          v.clearable && !v.$slots["clear-icon"] && e.inputValue && !v.disabled && !v.readonly ? (D(), ve(f(Ma), {
            key: 3,
            class: "dp__clear_icon dp__input_icons",
            onClick: E[3] || (E[3] = be((A) => y(A), ["prevent"]))
          })) : z("", !0)
        ])) : z("", !0)
      ]);
    };
  }
}), fl = ["title"], vl = { class: "dp__action_buttons" }, ml = ["onKeydown", "disabled"], gl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "ActionRow",
  props: {
    menuMount: { type: Boolean, default: !1 },
    calendarWidth: { type: Number, default: 0 },
    ...qe
  },
  emits: ["close-picker", "select-date", "select-now", "invalid-select"],
  setup(e, { emit: n }) {
    const a = e, {
      defaultedActionRow: t,
      defaultedPreviewFormat: r,
      defaultedMultiCalendars: l,
      defaultedTextInput: c,
      defaultedInline: b,
      getDefaultPattern: k
    } = Ae(a), { isValidTime: P } = Tt(a), { buildMatrix: g } = it(), S = X(null), Y = X(null);
    je(() => {
      a.arrowNavigation && g([Se(S), Se(Y)], "actionRow");
    });
    const G = W(() => a.range && !a.partialRange && a.internalModelValue ? a.internalModelValue.length === 2 : !0), N = W(() => !K.value || !J.value || !G.value), K = W(() => !a.enableTimePicker || a.ignoreTimeValidation ? !0 : P(a.internalModelValue)), J = W(() => a.monthPicker ? a.range && Array.isArray(a.internalModelValue) ? !a.internalModelValue.filter((y) => !re(y)).length : re(a.internalModelValue) : !0), h = () => {
      const Q = r.value;
      return a.timePicker || a.monthPicker, Q(Te(a.internalModelValue));
    }, O = () => {
      const Q = a.internalModelValue;
      return l.value.count > 0 ? `${p(Q[0])} - ${p(Q[1])}` : [p(Q[0]), p(Q[1])];
    }, p = (Q) => Ia(
      Q,
      r.value,
      a.formatLocale,
      c.value.rangeSeparator,
      a.modelAuto,
      k()
    ), m = W(() => !a.internalModelValue || !a.menuMount ? "" : typeof r.value == "string" ? Array.isArray(a.internalModelValue) ? a.internalModelValue.length === 2 && a.internalModelValue[1] ? O() : a.multiDates ? a.internalModelValue.map((Q) => `${p(Q)}`) : a.modelAuto ? `${p(a.internalModelValue[0])}` : `${p(a.internalModelValue[0])} -` : p(a.internalModelValue) : h()), C = () => a.multiDates ? "; " : " - ", j = W(
      () => Array.isArray(m.value) ? m.value.join(C()) : m.value
    ), re = (Q) => {
      if (!a.monthPicker)
        return !0;
      let y = !0;
      const w = H(Ge(Q));
      if (a.minDate && a.maxDate) {
        const L = H(Ge(a.minDate)), x = H(Ge(a.maxDate));
        return Ie(w, L) && Re(w, x) || ye(w, L) || ye(w, x);
      }
      if (a.minDate) {
        const L = H(Ge(a.minDate));
        y = Ie(w, L) || ye(w, L);
      }
      if (a.maxDate) {
        const L = H(Ge(a.maxDate));
        y = Re(w, L) || ye(w, L);
      }
      return y;
    }, ue = () => {
      K.value && J.value && G.value ? n("select-date") : n("invalid-select");
    };
    return (Q, y) => (D(), V("div", {
      class: "dp__action_row",
      style: Ze(e.calendarWidth ? { width: `${e.calendarWidth}px` } : {})
    }, [
      Q.$slots["action-row"] ? te(Q.$slots, "action-row", Pe(Ye({ key: 0 }, {
        internalModelValue: Q.internalModelValue,
        disabled: N.value,
        selectDate: () => Q.$emit("select-date"),
        closePicker: () => Q.$emit("close-picker")
      }))) : (D(), V(de, { key: 1 }, [
        f(t).showPreview ? (D(), V("div", {
          key: 0,
          class: "dp__selection_preview",
          title: j.value
        }, [
          Q.$slots["action-preview"] ? te(Q.$slots, "action-preview", {
            key: 0,
            value: Q.internalModelValue
          }) : z("", !0),
          Q.$slots["action-preview"] ? z("", !0) : (D(), V(de, { key: 1 }, [
            et(Ne(j.value), 1)
          ], 64))
        ], 8, fl)) : z("", !0),
        oe("div", vl, [
          Q.$slots["action-buttons"] ? te(Q.$slots, "action-buttons", {
            key: 0,
            value: Q.internalModelValue
          }) : z("", !0),
          Q.$slots["action-buttons"] ? z("", !0) : (D(), V(de, { key: 1 }, [
            !f(b).enabled && f(t).showCancel ? (D(), V("button", {
              key: 0,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: y[0] || (y[0] = (w) => Q.$emit("close-picker")),
              onKeydown: [
                y[1] || (y[1] = le((w) => Q.$emit("close-picker"), ["enter"])),
                y[2] || (y[2] = le((w) => Q.$emit("close-picker"), ["space"]))
              ]
            }, Ne(Q.cancelText), 545)) : z("", !0),
            f(t).showNow ? (D(), V("button", {
              key: 1,
              type: "button",
              ref_key: "cancelButtonRef",
              ref: S,
              class: "dp__action_button dp__action_cancel",
              onClick: y[3] || (y[3] = (w) => Q.$emit("select-now")),
              onKeydown: [
                y[4] || (y[4] = le((w) => Q.$emit("select-now"), ["enter"])),
                y[5] || (y[5] = le((w) => Q.$emit("select-now"), ["space"]))
              ]
            }, Ne(Q.nowButtonLabel), 545)) : z("", !0),
            f(t).showSelect ? (D(), V("button", {
              key: 2,
              type: "button",
              class: "dp__action_button dp__action_select",
              onKeydown: [
                le(ue, ["enter"]),
                le(ue, ["space"])
              ],
              onClick: ue,
              disabled: N.value,
              ref_key: "selectButtonRef",
              ref: Y
            }, Ne(Q.selectText), 41, ml)) : z("", !0)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), yl = ["onKeydown"], hl = { class: "dp__selection_grid_header" }, pl = ["aria-selected", "aria-disabled", "onClick", "onKeydown", "onMouseover"], bl = ["aria-label", "onKeydown"], Ht = /* @__PURE__ */ Oe({
  __name: "SelectionOverlay",
  props: {
    items: {},
    type: {},
    isLast: { type: Boolean },
    arrowNavigation: { type: Boolean },
    skipButtonRef: { type: Boolean },
    headerRefs: {},
    hideNavigation: {},
    escClose: { type: Boolean },
    useRelative: { type: Boolean },
    height: {},
    textInput: { type: [Boolean, Object] },
    config: {}
  },
  emits: ["selected", "toggle", "reset-flow", "hover-value"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setSelectionGrid: r, buildMultiLevelMatrix: l, setMonthPicker: c } = it(), { defaultedAriaLabels: b, defaultedTextInput: k, defaultedConfig: P } = Ae(
      t
    ), { hideNavigationButtons: g } = Jt(), S = X(!1), Y = X(null), G = X(null), N = X([]), K = X(), J = X(null), h = X(0), O = X(null);
    Wa(() => {
      Y.value = null;
    }), je(() => {
      st().then(() => y()), m(), p(!0);
    }), Nn(() => p(!1));
    const p = (i) => {
      var o;
      t.arrowNavigation && ((o = t.headerRefs) != null && o.length ? c(i) : r(i));
    }, m = () => {
      var o;
      const i = Se(G);
      i && (k.value.enabled || (Y.value ? (o = Y.value) == null || o.focus({ preventScroll: !0 }) : i.focus({ preventScroll: !0 })), S.value = i.clientHeight < i.scrollHeight);
    }, C = W(
      () => ({
        dp__overlay: !0,
        "dp--overlay-absolute": !t.useRelative,
        "dp--overlay-relative": t.useRelative
      })
    ), j = W(
      () => t.useRelative ? { height: `${t.height}px`, width: "260px" } : void 0
    ), re = W(() => ({
      dp__overlay_col: !0
    })), ue = W(
      () => ({
        dp__btn: !0,
        dp__button: !0,
        dp__overlay_action: !0,
        dp__over_action_scroll: S.value,
        dp__button_bottom: t.isLast
      })
    ), Q = W(() => {
      var i, o;
      return {
        dp__overlay_container: !0,
        dp__container_flex: ((i = t.items) == null ? void 0 : i.length) <= 6,
        dp__container_block: ((o = t.items) == null ? void 0 : o.length) > 6
      };
    }), y = () => {
      st().then(() => {
        const i = Se(Y), o = Se(G), $ = Se(J), Z = Se(O), s = $ ? $.getBoundingClientRect().height : 0;
        o && (h.value = o.getBoundingClientRect().height - s), i && Z && (Z.scrollTop = i.offsetTop - Z.offsetTop - (h.value / 2 - i.getBoundingClientRect().height) - s);
      });
    }, w = (i) => {
      i.disabled || a("selected", i.value);
    }, L = () => {
      a("toggle"), a("reset-flow");
    }, x = () => {
      t.escClose && L();
    }, v = (i, o, $, Z) => {
      i && (o.active && (Y.value = i), t.arrowNavigation && (Array.isArray(N.value[$]) ? N.value[$][Z] = i : N.value[$] = [i], E()));
    }, E = () => {
      var o, $;
      const i = (o = t.headerRefs) != null && o.length ? [t.headerRefs].concat(N.value) : N.value.concat([t.skipButtonRef ? [] : [J.value]]);
      l(Te(i), ($ = t.headerRefs) != null && $.length ? "monthPicker" : "selectionGrid");
    }, M = (i) => {
      t.arrowNavigation || lt(i, P.value, !0);
    }, A = (i) => {
      K.value = i, a("hover-value", i);
    };
    return n({ focusGrid: m }), (i, o) => {
      var $;
      return D(), V("div", {
        ref_key: "gridWrapRef",
        ref: G,
        class: he(C.value),
        style: Ze(j.value),
        role: "dialog",
        tabindex: "0",
        onKeydown: [
          le(be(x, ["prevent"]), ["esc"]),
          o[0] || (o[0] = le(be((Z) => M(Z), ["prevent"]), ["left"])),
          o[1] || (o[1] = le(be((Z) => M(Z), ["prevent"]), ["up"])),
          o[2] || (o[2] = le(be((Z) => M(Z), ["prevent"]), ["down"])),
          o[3] || (o[3] = le(be((Z) => M(Z), ["prevent"]), ["right"]))
        ]
      }, [
        oe("div", {
          class: he(Q.value),
          ref_key: "containerRef",
          ref: O,
          role: "grid",
          style: Ze({ height: `${h.value}px` })
        }, [
          oe("div", hl, [
            te(i.$slots, "header")
          ]),
          i.$slots.overlay ? te(i.$slots, "overlay", { key: 0 }) : (D(!0), V(de, { key: 1 }, De(i.items, (Z, s) => (D(), V("div", {
            class: he(["dp__overlay_row", { dp__flex_row: i.items.length >= 3 }]),
            key: s,
            role: "row"
          }, [
            (D(!0), V(de, null, De(Z, (I, pe) => (D(), V("div", {
              role: "gridcell",
              class: he(re.value),
              key: I.value,
              "aria-selected": I.active,
              "aria-disabled": I.disabled || void 0,
              ref_for: !0,
              ref: (u) => v(u, I, s, pe),
              tabindex: "0",
              onClick: (u) => w(I),
              onKeydown: [
                le(be((u) => w(I), ["prevent"]), ["enter"]),
                le(be((u) => w(I), ["prevent"]), ["space"])
              ],
              onMouseover: (u) => A(I.value)
            }, [
              oe("div", {
                class: he(I.className)
              }, [
                i.$slots.item ? te(i.$slots, "item", {
                  key: 0,
                  item: I
                }) : z("", !0),
                i.$slots.item ? z("", !0) : (D(), V(de, { key: 1 }, [
                  et(Ne(I.text), 1)
                ], 64))
              ], 2)
            ], 42, pl))), 128))
          ], 2))), 128))
        ], 6),
        i.$slots["button-icon"] ? jt((D(), V("button", {
          key: 0,
          type: "button",
          "aria-label": ($ = f(b)) == null ? void 0 : $.toggleOverlay,
          class: he(ue.value),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: J,
          onClick: L,
          onKeydown: [
            le(L, ["enter"]),
            le(L, ["tab"])
          ]
        }, [
          te(i.$slots, "button-icon")
        ], 42, bl)), [
          [Kt, !f(g)(i.hideNavigation, i.type)]
        ]) : z("", !0)
      ], 46, yl);
    };
  }
}), en = /* @__PURE__ */ Oe({
  __name: "InstanceWrap",
  props: {
    multiCalendars: {},
    stretch: { type: Boolean }
  },
  setup(e) {
    const n = e, a = W(
      () => n.multiCalendars > 0 ? [...Array(n.multiCalendars).keys()] : [0]
    ), t = W(() => ({
      dp__instance_calendar: n.multiCalendars > 0
    }));
    return (r, l) => (D(), V("div", {
      class: he({
        dp__menu_inner: !r.stretch,
        "dp--menu--inner-stretched": r.stretch,
        dp__flex_display: r.multiCalendars > 0
      })
    }, [
      (D(!0), V(de, null, De(a.value, (c, b) => (D(), V("div", {
        key: c,
        class: he(t.value)
      }, [
        te(r.$slots, "default", {
          instance: c,
          index: b
        })
      ], 2))), 128))
    ], 2));
  }
}), kl = ["aria-label", "aria-disabled"], Ct = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "ArrowBtn",
  props: {
    ariaLabel: {},
    disabled: { type: Boolean }
  },
  emits: ["activate", "set-ref"],
  setup(e, { emit: n }) {
    const a = X(null);
    return je(() => n("set-ref", a)), (t, r) => (D(), V("button", {
      type: "button",
      class: "dp__btn dp--arrow-btn-nav",
      onClick: r[0] || (r[0] = (l) => t.$emit("activate")),
      onKeydown: [
        r[1] || (r[1] = le(be((l) => t.$emit("activate"), ["prevent"]), ["enter"])),
        r[2] || (r[2] = le(be((l) => t.$emit("activate"), ["prevent"]), ["space"]))
      ],
      tabindex: "0",
      "aria-label": t.ariaLabel,
      "aria-disabled": t.disabled || void 0,
      ref_key: "elRef",
      ref: a
    }, [
      oe("span", {
        class: he(["dp__inner_nav", { dp__inner_nav_disabled: t.disabled }])
      }, [
        te(t.$slots, "default")
      ], 2)
    ], 40, kl));
  }
}), wl = { class: "dp--year-mode-picker" }, Dl = ["aria-label"], Ea = /* @__PURE__ */ Oe({
  __name: "YearModePicker",
  props: {
    ...qe,
    showYearPicker: { type: Boolean, default: !1 },
    items: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    isDisabled: { type: Function, default: () => !1 }
  },
  emits: ["toggle-year-picker", "year-select", "handle-year"],
  setup(e, { emit: n }) {
    const a = e, { showRightIcon: t, showLeftIcon: r } = Jt(), { defaultedConfig: l, defaultedMultiCalendars: c, defaultedAriaLabels: b, defaultedTransitions: k } = Ae(a), { showTransition: P, transitionName: g } = Et(k), S = (N = !1, K) => {
      n("toggle-year-picker", { flow: N, show: K });
    }, Y = (N) => {
      n("year-select", N);
    }, G = (N = !1) => {
      n("handle-year", N);
    };
    return (N, K) => {
      var J, h, O;
      return D(), V("div", wl, [
        f(r)(f(c), e.instance) ? (D(), ve(Ct, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": (J = f(b)) == null ? void 0 : J.prevYear,
          disabled: e.isDisabled(!1),
          onActivate: K[0] || (K[0] = (p) => G(!1))
        }, {
          default: ie(() => [
            N.$slots["arrow-left"] ? te(N.$slots, "arrow-left", { key: 0 }) : z("", !0),
            N.$slots["arrow-left"] ? z("", !0) : (D(), ve(f(Fn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : z("", !0),
        oe("button", {
          class: "dp__btn dp--year-select",
          type: "button",
          ref: "mpYearButtonRef",
          "aria-label": (h = f(b)) == null ? void 0 : h.openYearsOverlay,
          onClick: K[1] || (K[1] = () => S(!1)),
          onKeydown: K[2] || (K[2] = le(() => S(!1), ["enter"]))
        }, [
          N.$slots.year ? te(N.$slots, "year", {
            key: 0,
            year: e.year
          }) : z("", !0),
          N.$slots.year ? z("", !0) : (D(), V(de, { key: 1 }, [
            et(Ne(e.year), 1)
          ], 64))
        ], 40, Dl),
        f(t)(f(c), e.instance) ? (D(), ve(Ct, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": (O = f(b)) == null ? void 0 : O.nextYear,
          disabled: e.isDisabled(!0),
          onActivate: K[3] || (K[3] = (p) => G(!0))
        }, {
          default: ie(() => [
            N.$slots["arrow-right"] ? te(N.$slots, "arrow-right", { key: 0 }) : z("", !0),
            N.$slots["arrow-right"] ? z("", !0) : (D(), ve(f(Hn), { key: 1 }))
          ]),
          _: 3
        }, 8, ["aria-label", "disabled"])) : z("", !0),
        ze($t, {
          name: f(g)(e.showYearPicker),
          css: f(P)
        }, {
          default: ie(() => [
            e.showYearPicker ? (D(), ve(Ht, {
              key: 0,
              items: e.items,
              "text-input": N.textInput,
              "esc-close": N.escClose,
              config: N.config,
              onToggle: S,
              onSelected: K[4] || (K[4] = (p) => Y(p)),
              "is-last": N.autoApply && !f(l).keepActionRow,
              type: "year"
            }, Fe({
              "button-icon": ie(() => [
                N.$slots["calendar-icon"] ? te(N.$slots, "calendar-icon", { key: 0 }) : z("", !0),
                N.$slots["calendar-icon"] ? z("", !0) : (D(), ve(f(Bt), { key: 1 }))
              ]),
              _: 2
            }, [
              N.$slots["year-overlay-value"] ? {
                name: "item",
                fn: ie(({ item: p }) => [
                  te(N.$slots, "year-overlay-value", {
                    text: p.text,
                    value: p.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "text-input", "esc-close", "config", "is-last"])) : z("", !0)
          ]),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), tn = (e, n, a) => {
  if (n.value && Array.isArray(n.value))
    if (n.value.some((t) => ye(e, t))) {
      const t = n.value.filter((r) => !ye(r, e));
      n.value = t.length ? t : null;
    } else
      (a && +a > n.value.length || !a) && n.value.push(e);
  else
    n.value = [e];
}, Gn = (e, n, a) => {
  let t = e.value ? e.value.slice() : [];
  return t.length === 2 && t[1] !== null && (t = []), t.length ? Re(n, t[0]) ? (t.unshift(n), a("range-start", t[0]), a("range-start", t[1])) : (t[1] = n, a("range-end", n)) : (t = [n], a("range-start", n)), e.value = t, t;
}, nn = (e, n, a, t) => {
  e[0] && e[1] && a && n("auto-apply"), e[0] && !e[1] && t && a && n("auto-apply");
}, Fa = ({ multiCalendars: e, calendars: n, modelValue: a, props: t, year: r, month: l, emit: c }) => {
  const b = W(() => Kn(t.yearRange, t.reverseYears)), k = X([!1]), P = W(() => (p, m) => {
    const C = we(Ge(/* @__PURE__ */ new Date()), {
      month: l.value(p),
      year: r.value(p)
    });
    return Na(C, t.maxDate, t.minDate, t.preventMinMaxNavigation, m);
  }), g = () => {
    for (let p = 0; p < e.value.count; p++)
      if (p === 0)
        n.value[p] = n.value[0];
      else {
        const m = we(H(), n.value[p - 1]);
        n.value[p] = { month: me(m), year: ge(ka(m, 1)) };
      }
  }, S = (p) => {
    if (!p)
      return g();
    const m = we(H(), n.value[p]);
    return n.value[0].year = ge(wa(m, e.value.count - 1)), g();
  }, Y = (p) => t.focusStartDate ? p[0] : p[1] ? p[1] : p[0], G = () => {
    if (a.value) {
      const p = Array.isArray(a.value) ? Y(a.value) : a.value;
      n.value[0] = { month: me(p), year: ge(p) };
    }
  };
  je(() => {
    G(), e.value.count && g();
  });
  const N = (p, m) => {
    n.value[m].year = p, e.value.count && !e.value.solo && S(m);
  }, K = W(() => (p) => Dt(b.value, (m) => {
    const C = r.value(p) === m.value, j = Nt(m.value, Mt(t.minDate), Mt(t.maxDate));
    return { active: C, disabled: j };
  })), J = (p, m) => {
    N(p, m), O(m);
  }, h = (p, m = !1) => {
    if (!P.value(p, m)) {
      const C = m ? r.value(p) + 1 : r.value(p) - 1;
      N(C, p);
    }
  }, O = (p, m = !1, C) => {
    m || c("reset-flow"), C !== void 0 ? k.value[p] = C : k.value[p] = !k.value[p], k.value || c("overlay-closed");
  };
  return {
    isDisabled: P,
    groupedYears: K,
    showYearPicker: k,
    selectYear: N,
    toggleYearPicker: O,
    handleYearSelect: J,
    handleYear: h
  };
}, Ml = (e, n) => {
  const { defaultedMultiCalendars: a, defaultedAriaLabels: t, defaultedTransitions: r, defaultedConfig: l } = Ae(e), { modelValue: c, year: b, month: k, calendars: P } = Ft(e, n), g = W(() => Sa(e.formatLocale, e.locale, e.monthNameFormat)), S = X(null), {
    selectYear: Y,
    groupedYears: G,
    showYearPicker: N,
    toggleYearPicker: K,
    handleYearSelect: J,
    handleYear: h,
    isDisabled: O
  } = Fa({
    modelValue: c,
    multiCalendars: a,
    calendars: P,
    year: b,
    month: k,
    props: e,
    emit: n
  }), p = (A) => A ? { month: me(A), year: ge(A) } : { month: null, year: null }, m = () => c.value ? Array.isArray(c.value) ? c.value.map((A) => p(A)) : p(c.value) : p(), C = (A, i) => {
    const o = P.value[A], $ = m();
    return Array.isArray($) ? $.some((Z) => Z.year === (o == null ? void 0 : o.year) && Z.month === i) : (o == null ? void 0 : o.year) === $.year && i === $.month;
  }, j = (A, i, o) => {
    var Z, s;
    const $ = m();
    return Array.isArray($) ? b.value(i) === ((Z = $[o]) == null ? void 0 : Z.year) && A === ((s = $[o]) == null ? void 0 : s.month) : !1;
  }, re = (A, i) => {
    if (e.range) {
      const o = m();
      if (Array.isArray(c.value) && Array.isArray(o)) {
        const $ = j(A, i, 0) || j(A, i, 1), Z = xe(Ge(H()), A, b.value(i));
        return Xt(c.value, S.value, Z) && !$;
      }
      return !1;
    }
    return !1;
  }, ue = W(() => (A) => Dt(g.value, (i) => {
    const o = C(A, i.value), $ = Nt(
      i.value,
      _a(b.value(A), e.minDate),
      Ca(b.value(A), e.maxDate)
    ) || jr(e.disabledDates, b.value(A)).includes(i.value), Z = re(i.value, A);
    return { active: o, disabled: $, isBetween: Z };
  })), Q = (A, i) => xe(Ge(H()), A, b.value(i)), y = (A, i) => {
    const o = c.value ? c.value : Ge(/* @__PURE__ */ new Date());
    c.value = xe(o, A, b.value(i)), n("auto-apply");
  }, w = (A, i) => {
    const o = Gn(c, Q(A, i), n);
    nn(o, n, e.autoApply, e.modelAuto);
  }, L = (A, i) => {
    tn(Q(A, i), c, e.multiDatesLimit), n("auto-apply", !0);
  }, x = (A, i) => (P.value[i].month = A, E(i, P.value[i].year, A), e.multiDates ? L(A, i) : e.range ? w(A, i) : y(A, i)), v = (A, i) => {
    Y(A, i), E(i, A, null);
  }, E = (A, i, o) => {
    let $ = o;
    if (!$) {
      const Z = m();
      $ = Array.isArray(Z) ? Z[A].month : Z.month;
    }
    n("update-month-year", { instance: A, year: i, month: $ });
  };
  return {
    groupedMonths: ue,
    groupedYears: G,
    year: b,
    isDisabled: O,
    defaultedMultiCalendars: a,
    defaultedAriaLabels: t,
    defaultedTransitions: r,
    defaultedConfig: l,
    showYearPicker: N,
    setHoverDate: (A, i) => {
      S.value = Q(A, i);
    },
    selectMonth: x,
    selectYear: v,
    toggleYearPicker: K,
    handleYearSelect: J,
    handleYear: h
  };
}, $l = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "MonthPicker",
  props: {
    ...qe
  },
  emits: [
    "update:internal-model-value",
    "overlay-closed",
    "reset-flow",
    "range-start",
    "range-end",
    "auto-apply",
    "update-month-year"
  ],
  setup(e, { emit: n }) {
    const a = e, t = ht(), r = Ve(t, "yearMode"), {
      groupedMonths: l,
      groupedYears: c,
      year: b,
      isDisabled: k,
      defaultedMultiCalendars: P,
      defaultedConfig: g,
      showYearPicker: S,
      setHoverDate: Y,
      selectMonth: G,
      selectYear: N,
      toggleYearPicker: K,
      handleYearSelect: J,
      handleYear: h
    } = Ml(a, n);
    return (O, p) => (D(), ve(en, {
      "multi-calendars": f(P).count,
      stretch: ""
    }, {
      default: ie(({ instance: m }) => [
        O.$slots["month-year"] ? te(O.$slots, "month-year", Pe(Ye({ key: 0 }, {
          year: f(b),
          months: f(l)(m),
          years: f(c)(m),
          selectMonth: f(G),
          selectYear: f(N),
          instance: m
        }))) : (D(), ve(Ht, {
          key: 1,
          items: f(l)(m),
          "arrow-navigation": O.arrowNavigation,
          "is-last": O.autoApply && !f(g).keepActionRow,
          "esc-close": O.escClose,
          height: f(g).modeHeight,
          config: O.config,
          onSelected: (C) => f(G)(C, m),
          onHoverValue: (C) => f(Y)(C, m),
          "use-relative": "",
          type: "month"
        }, {
          header: ie(() => [
            ze(Ea, Ye(O.$props, {
              items: f(c)(m),
              instance: m,
              "show-year-picker": f(S)[m],
              year: f(b)(m),
              "is-disabled": (C) => f(k)(m, C),
              onHandleYear: (C) => f(h)(m, C),
              onYearSelect: (C) => f(J)(C, m),
              onToggleYearPicker: (C) => f(K)(m, C == null ? void 0 : C.flow, C == null ? void 0 : C.show)
            }), Fe({ _: 2 }, [
              De(f(r), (C, j) => ({
                name: C,
                fn: ie((re) => [
                  te(O.$slots, C, Pe(He(re)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          _: 2
        }, 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "onSelected", "onHoverValue"]))
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
}), Tl = (e, n) => {
  const { modelValue: a } = Ft(e, n), t = X(null), r = (g) => Array.isArray(a.value) ? a.value.some((S) => ge(S) === g) : a.value ? ge(a.value) === g : !1, l = (g) => e.range && Array.isArray(a.value) ? Xt(a.value, t.value, b(g)) : !1, c = W(() => Dt(Kn(e.yearRange, e.reverseYears), (g) => {
    const S = r(g.value), Y = Nt(g.value, Mt(e.minDate), Mt(e.maxDate)), G = l(g.value);
    return { active: S, disabled: Y, isBetween: G };
  })), b = (g) => ft(Ge(/* @__PURE__ */ new Date()), g);
  return {
    groupedYears: c,
    setHoverValue: (g) => {
      t.value = ft(Ge(/* @__PURE__ */ new Date()), g);
    },
    selectYear: (g) => {
      if (e.multiDates)
        return tn(b(g), a, e.multiDatesLimit), n("auto-apply", !0);
      if (e.range) {
        const S = Gn(a, b(g), n);
        return nn(S, n, e.autoApply, e.modelAuto);
      }
      a.value = b(g), n("auto-apply");
    }
  };
}, Al = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "YearPicker",
  props: {
    ...qe
  },
  emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply"],
  setup(e, { emit: n }) {
    const a = e, { groupedYears: t, selectYear: r, setHoverValue: l } = Tl(a, n), { defaultedConfig: c } = Ae(a);
    return (b, k) => (D(), V("div", null, [
      b.$slots["month-year"] ? te(b.$slots, "month-year", Pe(Ye({ key: 0 }, {
        years: f(t),
        selectYear: f(r)
      }))) : (D(), ve(Ht, {
        key: 1,
        items: f(t),
        "is-last": b.autoApply && !f(c).keepActionRow,
        height: f(c).modeHeight,
        config: b.config,
        type: "year",
        "use-relative": "",
        onSelected: f(r),
        onHoverValue: f(l)
      }, Fe({ _: 2 }, [
        b.$slots["year-overlay-value"] ? {
          name: "item",
          fn: ie(({ item: P }) => [
            te(b.$slots, "year-overlay-value", {
              text: P.text,
              value: P.value
            })
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["items", "is-last", "height", "config", "onSelected", "onHoverValue"]))
    ]));
  }
}), Sl = {
  key: 0,
  class: "dp__time_input"
}, Pl = ["aria-label", "onKeydown", "onClick"], _l = /* @__PURE__ */ oe("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), Cl = /* @__PURE__ */ oe("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), Rl = ["aria-label", "disabled", "onKeydown", "onClick"], Yl = ["aria-label", "onKeydown", "onClick"], Ol = /* @__PURE__ */ oe("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_l" }, null, -1), Nl = /* @__PURE__ */ oe("span", { class: "dp__tp_inline_btn_bar dp__tp_btn_in_r" }, null, -1), Il = { key: 0 }, Bl = ["aria-label", "onKeydown"], El = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: { type: Function, default: () => !1 },
    ...qe
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { setTimePickerElements: r, setTimePickerBackRef: l } = it(), { defaultedAriaLabels: c, defaultedTransitions: b, defaultedFilters: k, defaultedConfig: P } = Ae(t), { transitionName: g, showTransition: S } = Et(b), Y = It({
      hours: !1,
      minutes: !1,
      seconds: !1
    }), G = X("AM"), N = X(null), K = X([]);
    je(() => {
      a("mounted");
    });
    const J = (u) => we(/* @__PURE__ */ new Date(), {
      hours: u.hours,
      minutes: u.minutes,
      seconds: t.enableSeconds ? u.seconds : 0,
      milliseconds: 0
    }), h = W(
      () => (u) => x(u, t[u]) || p(u, t[u])
    ), O = W(() => ({ hours: t.hours, minutes: t.minutes, seconds: t.seconds })), p = (u, B) => t.range && !t.disableTimeRangeValidation ? !t.validateTime(u, B) : !1, m = (u, B) => {
      if (t.range && !t.disableTimeRangeValidation) {
        const U = B ? +t[`${u}Increment`] : -+t[`${u}Increment`], _ = t[u] + U;
        return !t.validateTime(u, _);
      }
      return !1;
    }, C = W(() => (u) => !E(+t[u] + +t[`${u}Increment`], u) || m(u, !0)), j = W(() => (u) => !E(+t[u] - +t[`${u}Increment`], u) || m(u, !1)), re = (u, B) => Da(we(H(), u), B), ue = (u, B) => er(we(H(), u), B), Q = W(
      () => ({
        dp__time_col: !0,
        dp__time_col_block: !t.timePickerInline,
        dp__time_col_reg_block: !t.enableSeconds && t.is24 && !t.timePickerInline,
        dp__time_col_reg_inline: !t.enableSeconds && t.is24 && t.timePickerInline,
        dp__time_col_reg_with_button: !t.enableSeconds && !t.is24,
        dp__time_col_sec: t.enableSeconds && t.is24,
        dp__time_col_sec_with_button: t.enableSeconds && !t.is24
      })
    ), y = W(() => {
      const u = [{ type: "hours" }, { type: "", separator: !0 }, { type: "minutes" }];
      return t.enableSeconds ? u.concat([{ type: "", separator: !0 }, { type: "seconds" }]) : u;
    }), w = W(() => y.value.filter((u) => !u.separator)), L = W(() => (u) => {
      if (u === "hours") {
        const B = $(+t.hours);
        return { text: B < 10 ? `0${B}` : `${B}`, value: B };
      }
      return { text: t[u] < 10 ? `0${t[u]}` : `${t[u]}`, value: t[u] };
    }), x = (u, B) => {
      var _;
      if (!t.disabledTimesConfig)
        return !1;
      const U = t.disabledTimesConfig(t.order, u === "hours" ? B : void 0);
      return U[u] ? !!((_ = U[u]) != null && _.includes(B)) : !0;
    }, v = (u) => {
      const B = t.is24 ? 24 : 12, U = u === "hours" ? B : 60, _ = +t[`${u}GridIncrement`], q = u === "hours" && !t.is24 ? _ : 0, ce = [];
      for (let fe = q; fe < U; fe += _)
        ce.push({ value: fe, text: fe < 10 ? `0${fe}` : `${fe}` });
      return u === "hours" && !t.is24 && ce.push({ value: 0, text: "12" }), Dt(ce, (fe) => ({ active: !1, disabled: k.value.times[u].includes(fe.value) || !E(fe.value, u) || x(u, fe.value) || p(u, fe.value) }));
    }, E = (u, B) => {
      const U = t.minTime ? J(pn(t.minTime)) : null, _ = t.maxTime ? J(pn(t.maxTime)) : null, q = J(pn(O.value, B, u));
      return U && _ ? (Rt(q, _) || kt(q, _)) && (Yt(q, U) || kt(q, U)) : U ? Yt(q, U) || kt(q, U) : _ ? Rt(q, _) || kt(q, _) : !0;
    }, M = (u) => t[`no${u[0].toUpperCase() + u.slice(1)}Overlay`], A = (u) => {
      M(u) || (Y[u] = !Y[u], Y[u] || a("overlay-closed"));
    }, i = (u) => u === "hours" ? Qe : u === "minutes" ? Je : wt, o = (u, B = !0) => {
      const U = B ? re : ue, _ = B ? +t[`${u}Increment`] : -+t[`${u}Increment`];
      E(+t[u] + _, u) && a(
        `update:${u}`,
        i(u)(U({ [u]: +t[u] }, { [u]: +t[`${u}Increment`] }))
      );
    }, $ = (u) => t.is24 ? u : (u >= 12 ? G.value = "PM" : G.value = "AM", Ir(u)), Z = () => {
      G.value === "PM" ? (G.value = "AM", a("update:hours", t.hours - 12)) : (G.value = "PM", a("update:hours", t.hours + 12)), a("am-pm-change", G.value);
    }, s = (u) => {
      Y[u] = !0;
    }, I = (u, B, U) => {
      if (u && t.arrowNavigation) {
        Array.isArray(K.value[B]) ? K.value[B][U] = u : K.value[B] = [u];
        const _ = K.value.reduce(
          (q, ce) => ce.map((fe, R) => [...q[R] || [], ce[R]]),
          []
        );
        l(t.closeTimePickerBtn), N.value && (_[1] = _[1].concat(N.value)), r(_, t.order);
      }
    }, pe = (u, B) => (A(u), u === "hours" && !t.is24 ? a(`update:${u}`, G.value === "PM" ? B + 12 : B) : a(`update:${u}`, B));
    return n({ openChildCmp: s }), (u, B) => {
      var U;
      return u.disabled ? z("", !0) : (D(), V("div", Sl, [
        (D(!0), V(de, null, De(y.value, (_, q) => {
          var ce, fe, R;
          return D(), V("div", {
            key: q,
            class: he(Q.value)
          }, [
            _.separator ? (D(), V(de, { key: 0 }, [
              et(" : ")
            ], 64)) : (D(), V(de, { key: 1 }, [
              oe("button", {
                type: "button",
                class: he({
                  dp__btn: !0,
                  dp__inc_dec_button: !u.timePickerInline,
                  dp__inc_dec_button_inline: u.timePickerInline,
                  dp__tp_inline_btn_top: u.timePickerInline,
                  dp__inc_dec_button_disabled: C.value(_.type)
                }),
                "aria-label": (ce = f(c)) == null ? void 0 : ce.incrementValue(_.type),
                tabindex: "0",
                onKeydown: [
                  le(be((F) => o(_.type), ["prevent"]), ["enter"]),
                  le(be((F) => o(_.type), ["prevent"]), ["space"])
                ],
                onClick: (F) => o(_.type),
                ref_for: !0,
                ref: (F) => I(F, q, 0)
              }, [
                t.timePickerInline ? (D(), V(de, { key: 1 }, [
                  _l,
                  Cl
                ], 64)) : (D(), V(de, { key: 0 }, [
                  u.$slots["arrow-up"] ? te(u.$slots, "arrow-up", { key: 0 }) : z("", !0),
                  u.$slots["arrow-up"] ? z("", !0) : (D(), ve(f(Ln), { key: 1 }))
                ], 64))
              ], 42, Pl),
              oe("button", {
                type: "button",
                "aria-label": (fe = f(c)) == null ? void 0 : fe.openTpOverlay(_.type),
                class: he({
                  dp__time_display: !0,
                  dp__time_display_block: !u.timePickerInline,
                  dp__time_display_inline: u.timePickerInline,
                  "dp--time-invalid": h.value(_.type),
                  "dp--time-overlay-btn": !h.value(_.type)
                }),
                disabled: M(_.type),
                tabindex: "0",
                onKeydown: [
                  le(be((F) => A(_.type), ["prevent"]), ["enter"]),
                  le(be((F) => A(_.type), ["prevent"]), ["space"])
                ],
                onClick: (F) => A(_.type),
                ref_for: !0,
                ref: (F) => I(F, q, 1)
              }, [
                u.$slots[_.type] ? te(u.$slots, _.type, {
                  key: 0,
                  text: L.value(_.type).text,
                  value: L.value(_.type).value
                }) : z("", !0),
                u.$slots[_.type] ? z("", !0) : (D(), V(de, { key: 1 }, [
                  et(Ne(L.value(_.type).text), 1)
                ], 64))
              ], 42, Rl),
              oe("button", {
                type: "button",
                class: he({
                  dp__btn: !0,
                  dp__inc_dec_button: !u.timePickerInline,
                  dp__inc_dec_button_inline: u.timePickerInline,
                  dp__tp_inline_btn_bottom: u.timePickerInline,
                  dp__inc_dec_button_disabled: j.value(_.type)
                }),
                "aria-label": (R = f(c)) == null ? void 0 : R.decrementValue(_.type),
                tabindex: "0",
                onKeydown: [
                  le(be((F) => o(_.type, !1), ["prevent"]), ["enter"]),
                  le(be((F) => o(_.type, !1), ["prevent"]), ["space"])
                ],
                onClick: (F) => o(_.type, !1),
                ref_for: !0,
                ref: (F) => I(F, q, 2)
              }, [
                t.timePickerInline ? (D(), V(de, { key: 1 }, [
                  Ol,
                  Nl
                ], 64)) : (D(), V(de, { key: 0 }, [
                  u.$slots["arrow-down"] ? te(u.$slots, "arrow-down", { key: 0 }) : z("", !0),
                  u.$slots["arrow-down"] ? z("", !0) : (D(), ve(f(Un), { key: 1 }))
                ], 64))
              ], 42, Yl)
            ], 64))
          ], 2);
        }), 128)),
        u.is24 ? z("", !0) : (D(), V("div", Il, [
          u.$slots["am-pm-button"] ? te(u.$slots, "am-pm-button", {
            key: 0,
            toggle: Z,
            value: G.value
          }) : z("", !0),
          u.$slots["am-pm-button"] ? z("", !0) : (D(), V("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: N,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (U = f(c)) == null ? void 0 : U.amPmButton,
            tabindex: "0",
            onClick: Z,
            onKeydown: [
              le(be(Z, ["prevent"]), ["enter"]),
              le(be(Z, ["prevent"]), ["space"])
            ]
          }, Ne(G.value), 41, Bl))
        ])),
        (D(!0), V(de, null, De(w.value, (_, q) => (D(), ve($t, {
          key: q,
          name: f(g)(Y[_.type]),
          css: f(S)
        }, {
          default: ie(() => [
            Y[_.type] ? (D(), ve(Ht, {
              key: 0,
              items: v(_.type),
              "is-last": u.autoApply && !f(P).keepActionRow,
              "esc-close": u.escClose,
              type: _.type,
              "text-input": u.textInput,
              config: u.config,
              "arrow-navigation": u.arrowNavigation,
              onSelected: (ce) => pe(_.type, ce),
              onToggle: (ce) => A(_.type),
              onResetFlow: B[0] || (B[0] = (ce) => u.$emit("reset-flow"))
            }, Fe({
              "button-icon": ie(() => [
                u.$slots["clock-icon"] ? te(u.$slots, "clock-icon", { key: 0 }) : z("", !0),
                u.$slots["clock-icon"] ? z("", !0) : (D(), ve(f(Vn), { key: 1 }))
              ]),
              _: 2
            }, [
              u.$slots[`${_.type}-overlay-value`] ? {
                name: "item",
                fn: ie(({ item: ce }) => [
                  te(u.$slots, `${_.type}-overlay-value`, {
                    text: ce.text,
                    value: ce.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "onSelected", "onToggle"])) : z("", !0)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Fl = { class: "dp--tp-wrap" }, Hl = ["aria-label"], Vl = ["tabindex"], Ll = ["aria-label"], Ha = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    disabledTimesConfig: { type: Function, default: null },
    validateTime: {
      type: Function,
      default: () => !1
    },
    ...qe
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-opened",
    "overlay-closed",
    "am-pm-change"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMatrix: r, setTimePicker: l } = it(), c = ht(), { defaultedTransitions: b, defaultedAriaLabels: k, defaultedTextInput: P, defaultedConfig: g } = Ae(t), { transitionName: S, showTransition: Y } = Et(b), { hideNavigationButtons: G } = Jt(), N = X(null), K = X(null), J = X([]), h = X(null);
    je(() => {
      a("mount"), !t.timePicker && t.arrowNavigation ? r([Se(N.value)], "time") : l(!0, t.timePicker);
    });
    const O = W(() => t.range && t.modelAuto ? Pa(t.internalModelValue) : !0), p = X(!1), m = (v) => ({
      hours: Array.isArray(t.hours) ? t.hours[v] : t.hours,
      minutes: Array.isArray(t.minutes) ? t.minutes[v] : t.minutes,
      seconds: Array.isArray(t.seconds) ? t.seconds[v] : t.seconds
    }), C = W(() => {
      const v = [];
      if (t.range)
        for (let E = 0; E < 2; E++)
          v.push(m(E));
      else
        v.push(m(0));
      return v;
    }), j = (v, E = !1, M = "") => {
      E || a("reset-flow"), p.value = v, a(v ? "overlay-opened" : "overlay-closed"), t.arrowNavigation && l(v), st(() => {
        M !== "" && J.value[0] && J.value[0].openChildCmp(M);
      });
    }, re = W(() => ({
      dp__btn: !0,
      dp__button: !0,
      dp__button_bottom: t.autoApply && !g.value.keepActionRow
    })), ue = Ve(c, "timePicker"), Q = (v, E, M) => t.range ? E === 0 ? [v, C.value[1][M]] : [C.value[0][M], v] : v, y = (v) => {
      a("update:hours", v);
    }, w = (v) => {
      a("update:minutes", v);
    }, L = (v) => {
      a("update:seconds", v);
    }, x = () => {
      if (h.value && !P.value.enabled) {
        const v = Er(h.value);
        v && v.focus({ preventScroll: !0 });
      }
    };
    return n({ toggleTimePicker: j }), (v, E) => {
      var M;
      return D(), V("div", Fl, [
        !v.timePicker && !v.timePickerInline ? jt((D(), V("button", {
          key: 0,
          type: "button",
          class: he(re.value),
          "aria-label": (M = f(k)) == null ? void 0 : M.openTimePicker,
          tabindex: "0",
          ref_key: "openTimePickerBtn",
          ref: N,
          onKeydown: [
            E[0] || (E[0] = le((A) => j(!0), ["enter"])),
            E[1] || (E[1] = le((A) => j(!0), ["space"]))
          ],
          onClick: E[2] || (E[2] = (A) => j(!0))
        }, [
          v.$slots["clock-icon"] ? te(v.$slots, "clock-icon", { key: 0 }) : z("", !0),
          v.$slots["clock-icon"] ? z("", !0) : (D(), ve(f(Vn), { key: 1 }))
        ], 42, Hl)), [
          [Kt, !f(G)(v.hideNavigation, "time")]
        ]) : z("", !0),
        ze($t, {
          name: f(S)(p.value),
          css: f(Y) && !v.timePickerInline
        }, {
          default: ie(() => {
            var A;
            return [
              p.value || v.timePicker || v.timePickerInline ? (D(), V("div", {
                key: 0,
                class: he({
                  dp__overlay: !v.timePickerInline,
                  "dp--overlay-absolute": !t.timePicker && !v.timePickerInline,
                  "dp--overlay-relative": t.timePicker
                }),
                style: Ze(v.timePicker ? { height: `${f(g).modeHeight}px` } : void 0),
                ref_key: "overlayRef",
                ref: h,
                tabindex: v.timePickerInline ? void 0 : 0
              }, [
                oe("div", {
                  class: he(
                    v.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"
                  ),
                  style: { display: "flex" }
                }, [
                  v.$slots["time-picker-overlay"] ? te(v.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e.hours,
                    minutes: e.minutes,
                    seconds: e.seconds,
                    setHours: y,
                    setMinutes: w,
                    setSeconds: L
                  }) : z("", !0),
                  v.$slots["time-picker-overlay"] ? z("", !0) : (D(), V("div", {
                    key: 1,
                    class: he(v.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
                  }, [
                    (D(!0), V(de, null, De(C.value, (i, o) => jt((D(), ve(El, Ye({ key: o }, {
                      ...v.$props,
                      order: o,
                      hours: i.hours,
                      minutes: i.minutes,
                      seconds: i.seconds,
                      closeTimePickerBtn: K.value,
                      disabledTimesConfig: e.disabledTimesConfig,
                      disabled: o === 0 ? v.fixedStart : v.fixedEnd
                    }, {
                      "validate-time": ($, Z) => e.validateTime($, Q(Z, o, $)),
                      ref_for: !0,
                      ref_key: "timeInputRefs",
                      ref: J,
                      "onUpdate:hours": ($) => y(Q($, o, "hours")),
                      "onUpdate:minutes": ($) => w(Q($, o, "minutes")),
                      "onUpdate:seconds": ($) => L(Q($, o, "seconds")),
                      onMounted: x,
                      onOverlayClosed: x,
                      onAmPmChange: E[3] || (E[3] = ($) => v.$emit("am-pm-change", $))
                    }), Fe({ _: 2 }, [
                      De(f(ue), ($, Z) => ({
                        name: $,
                        fn: ie((s) => [
                          te(v.$slots, $, Pe(He(s)))
                        ])
                      }))
                    ]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [Kt, o === 0 ? !0 : O.value]
                    ])), 128))
                  ], 2)),
                  !v.timePicker && !v.timePickerInline ? jt((D(), V("button", {
                    key: 2,
                    type: "button",
                    ref_key: "closeTimePickerBtn",
                    ref: K,
                    class: he(re.value),
                    "aria-label": (A = f(k)) == null ? void 0 : A.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      E[4] || (E[4] = le((i) => j(!1), ["enter"])),
                      E[5] || (E[5] = le((i) => j(!1), ["space"]))
                    ],
                    onClick: E[6] || (E[6] = (i) => j(!1))
                  }, [
                    v.$slots["calendar-icon"] ? te(v.$slots, "calendar-icon", { key: 0 }) : z("", !0),
                    v.$slots["calendar-icon"] ? z("", !0) : (D(), ve(f(Bt), { key: 1 }))
                  ], 42, Ll)), [
                    [Kt, !f(G)(v.hideNavigation, "time")]
                  ]) : z("", !0)
                ], 2)
              ], 14, Vl)) : z("", !0)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Va = (e, n, a, t) => {
  const r = (h, O) => Array.isArray(n[h]) ? n[h][O] : n[h], l = (h) => e.enableSeconds ? Array.isArray(n.seconds) ? n.seconds[h] : n.seconds : 0, c = (h, O) => h ? O !== void 0 ? ot(h, r("hours", O), r("minutes", O), l(O)) : ot(h, n.hours, n.minutes, l()) : Bn(H(), l(O)), b = (h, O) => {
    n[h] = O;
  }, k = (h, O) => {
    const p = Object.fromEntries(
      Object.keys(n).map((m) => m === h ? [m, O] : [m, n[m]].slice())
    );
    if (e.range && !e.disableTimeRangeValidation) {
      const m = (j) => a.value ? ot(
        a.value[j],
        p.hours[j],
        p.minutes[j],
        p.seconds[j]
      ) : null, C = (j) => En(a.value[j], 0);
      return !(ye(m(0), m(1)) && (Yt(m(0), C(1)) || Rt(m(1), C(0))));
    }
    return !0;
  }, P = (h, O) => {
    k(h, O) && (b(h, O), t && t());
  }, g = (h) => {
    P("hours", h);
  }, S = (h) => {
    P("minutes", h);
  }, Y = (h) => {
    P("seconds", h);
  }, G = (h, O, p, m) => {
    O && g(h), !O && !p && S(h), p && Y(h), a.value && m(a.value);
  }, N = (h) => {
    if (h) {
      const O = Array.isArray(h), p = O ? [+h[0].hours, +h[1].hours] : +h.hours, m = O ? [+h[0].minutes, +h[1].minutes] : +h.minutes, C = O ? [+h[0].seconds, +h[1].seconds] : +h.seconds;
      b("hours", p), b("minutes", m), e.enableSeconds && b("seconds", C);
    }
  }, K = (h, O) => {
    const p = {
      hours: Array.isArray(n.hours) ? n.hours[h] : n.hours,
      disabledArr: []
    };
    return (O || O === 0) && (p.hours = O), Array.isArray(e.disabledTimes) && (p.disabledArr = e.range && Array.isArray(e.disabledTimes[h]) ? e.disabledTimes[h] : e.disabledTimes), p;
  }, J = W(() => (h, O) => {
    var p;
    if (Array.isArray(e.disabledTimes)) {
      const { disabledArr: m, hours: C } = K(h, O), j = m.filter((re) => +re.hours === C);
      return ((p = j[0]) == null ? void 0 : p.minutes) === "*" ? { hours: [C], minutes: void 0, seconds: void 0 } : {
        hours: [],
        minutes: (j == null ? void 0 : j.map((re) => +re.minutes)) ?? [],
        seconds: (j == null ? void 0 : j.map((re) => re.seconds ? +re.seconds : void 0)) ?? []
      };
    }
    return { hours: [], minutes: [], seconds: [] };
  });
  return {
    setTime: b,
    updateHours: g,
    updateMinutes: S,
    updateSeconds: Y,
    getSetDateTime: c,
    updateTimeValues: G,
    getSecondsValue: l,
    assignStartTime: N,
    validateTime: k,
    disabledTimesConfig: J
  };
}, Ul = (e, n) => {
  const { modelValue: a, time: t } = Ft(e, n), { defaultedStartTime: r } = Ae(e), { updateTimeValues: l, getSetDateTime: c, setTime: b, assignStartTime: k, disabledTimesConfig: P, validateTime: g } = Va(e, t, a), S = (p) => {
    const { hours: m, minutes: C, seconds: j } = p;
    return { hours: +m, minutes: +C, seconds: j ? +j : 0 };
  }, Y = () => {
    if (e.startTime) {
      if (Array.isArray(e.startTime)) {
        const m = S(e.startTime[0]), C = S(e.startTime[1]);
        return [we(H(), m), we(H(), C)];
      }
      const p = S(e.startTime);
      return we(H(), p);
    }
    return e.range ? [null, null] : null;
  }, G = () => {
    if (e.range) {
      const [p, m] = Y();
      a.value = [c(p, 0), c(m, 1)];
    } else
      a.value = c(Y());
  }, N = (p) => Array.isArray(p) ? [mt(H(p[0])), mt(H(p[1]))] : [mt(p ?? H())], K = (p, m, C) => {
    b("hours", p), b("minutes", m), b("seconds", e.enableSeconds ? C : 0);
  }, J = () => {
    const [p, m] = N(a.value);
    return e.range ? K(
      [p.hours, m.hours],
      [p.minutes, m.minutes],
      [p.seconds, m.minutes]
    ) : K(p.hours, p.minutes, p.seconds);
  };
  je(() => {
    if (!e.shadow)
      return k(r.value), a.value ? J() : G();
  });
  const h = () => {
    Array.isArray(a.value) ? a.value = a.value.map((p, m) => p && c(p, m)) : a.value = c(a.value), n("time-update");
  };
  return {
    time: t,
    disabledTimesConfig: P,
    updateTime: (p, m = !0, C = !1) => {
      l(p, m, C, h);
    },
    validateTime: g
  };
}, zl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "TimePickerSolo",
  props: {
    ...qe
  },
  emits: ["update:internal-model-value", "time-update", "am-pm-change"],
  setup(e, { emit: n }) {
    const a = e, t = ht(), r = Ve(t, "timePicker"), { time: l, disabledTimesConfig: c, updateTime: b, validateTime: k } = Ul(a, n);
    return (P, g) => (D(), ve(en, {
      "multi-calendars": 0,
      stretch: ""
    }, {
      default: ie(() => [
        ze(Ha, Ye(P.$props, {
          hours: f(l).hours,
          minutes: f(l).minutes,
          seconds: f(l).seconds,
          "internal-model-value": P.internalModelValue,
          "disabled-times-config": f(c),
          "validate-time": f(k),
          "onUpdate:hours": g[0] || (g[0] = (S) => f(b)(S)),
          "onUpdate:minutes": g[1] || (g[1] = (S) => f(b)(S, !1)),
          "onUpdate:seconds": g[2] || (g[2] = (S) => f(b)(S, !1, !0)),
          onAmPmChange: g[3] || (g[3] = (S) => P.$emit("am-pm-change", S))
        }), Fe({ _: 2 }, [
          De(f(r), (S, Y) => ({
            name: S,
            fn: ie((G) => [
              te(P.$slots, S, Pe(He(G)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])
      ]),
      _: 3
    }));
  }
}), Wl = { class: "dp__month_year_row" }, jl = ["aria-label", "onClick", "onKeydown"], Kl = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DpHeader",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    ...qe
  },
  emits: ["update-month-year", "mount", "reset-flow", "overlay-closed"],
  setup(e, { expose: n, emit: a }) {
    const t = e, { defaultedTransitions: r, defaultedAriaLabels: l, defaultedMultiCalendars: c, defaultedFilters: b, defaultedConfig: k } = Ae(t), { transitionName: P, showTransition: g } = Et(r), { buildMatrix: S } = it(), { handleMonthYearChange: Y, isDisabled: G, updateMonthYear: N } = nl(t, a), { showLeftIcon: K, showRightIcon: J } = Jt(), h = X(!1), O = X(!1), p = X([null, null, null, null]);
    je(() => {
      a("mount");
    });
    const m = (i) => ({
      get: () => t[i],
      set: (o) => {
        const $ = i === Ke.month ? Ke.year : Ke.month;
        a("update-month-year", { [i]: o, [$]: t[$] }), i === Ke.month ? L(!0) : x(!0);
      }
    }), C = W(m(Ke.month)), j = W(m(Ke.year)), re = W(() => (i) => ({
      month: t.month,
      year: t.year,
      items: i === Ke.month ? t.months : t.years,
      instance: t.instance,
      updateMonthYear: N,
      toggle: i === Ke.month ? L : x
    })), ue = W(() => {
      const i = t.months.find((o) => o.value === t.month);
      return i || { text: "", value: 0 };
    }), Q = W(() => Dt(t.months, (i) => {
      const o = t.month === i.value, $ = Nt(
        i.value,
        _a(t.year, t.minDate),
        Ca(t.year, t.maxDate)
      ) || b.value.months.includes(i.value);
      return { active: o, disabled: $ };
    })), y = W(() => Dt(t.years, (i) => {
      const o = t.year === i.value, $ = Nt(i.value, Mt(t.minDate), Mt(t.maxDate)) || b.value.years.includes(i.value);
      return { active: o, disabled: $ };
    })), w = (i, o) => {
      o !== void 0 ? i.value = o : i.value = !i.value, i.value || a("overlay-closed");
    }, L = (i = !1, o) => {
      v(i), w(h, o);
    }, x = (i = !1, o) => {
      v(i), w(O, o);
    }, v = (i) => {
      i || a("reset-flow");
    }, E = (i, o) => {
      t.arrowNavigation && (p.value[o] = Se(i), S(p.value, "monthYear"));
    }, M = W(() => {
      var i, o;
      return [
        {
          type: Ke.month,
          index: 1,
          toggle: L,
          modelValue: C.value,
          updateModelValue: ($) => C.value = $,
          text: ue.value.text,
          showSelectionGrid: h.value,
          items: Q.value,
          ariaLabel: (i = l.value) == null ? void 0 : i.openMonthsOverlay
        },
        {
          type: Ke.year,
          index: 2,
          toggle: x,
          modelValue: j.value,
          updateModelValue: ($) => j.value = $,
          text: t.year,
          showSelectionGrid: O.value,
          items: y.value,
          ariaLabel: (o = l.value) == null ? void 0 : o.openYearsOverlay
        }
      ];
    }), A = W(
      () => t.disableYearSelect ? [M.value[0]] : M.value
    );
    return n({
      toggleMonthPicker: L,
      toggleYearPicker: x,
      handleMonthYearChange: Y
    }), (i, o) => {
      var $, Z, s;
      return D(), V("div", Wl, [
        i.$slots["month-year"] ? te(i.$slots, "month-year", Pe(Ye({ key: 0 }, { month: e.month, year: e.year, months: e.months, years: e.years, updateMonthYear: f(N), handleMonthYearChange: f(Y), instance: e.instance }))) : (D(), V(de, { key: 1 }, [
          f(K)(f(c), e.instance) && !i.vertical ? (D(), ve(Ct, {
            key: 0,
            "aria-label": ($ = f(l)) == null ? void 0 : $.prevMonth,
            disabled: f(G)(!1),
            onActivate: o[0] || (o[0] = (I) => f(Y)(!1, !0)),
            onSetRef: o[1] || (o[1] = (I) => E(I, 0))
          }, {
            default: ie(() => [
              i.$slots["arrow-left"] ? te(i.$slots, "arrow-left", { key: 0 }) : z("", !0),
              i.$slots["arrow-left"] ? z("", !0) : (D(), ve(f(Fn), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : z("", !0),
          oe("div", {
            class: he(["dp__month_year_wrap", {
              dp__year_disable_select: i.disableYearSelect
            }])
          }, [
            (D(!0), V(de, null, De(A.value, (I, pe) => (D(), V(de, {
              key: I.type
            }, [
              oe("button", {
                type: "button",
                class: "dp__btn dp__month_year_select",
                tabindex: "0",
                "aria-label": I.ariaLabel,
                ref_for: !0,
                ref: (u) => E(u, pe + 1),
                onClick: I.toggle,
                onKeydown: [
                  le(be(I.toggle, ["prevent"]), ["enter"]),
                  le(be(I.toggle, ["prevent"]), ["space"])
                ]
              }, [
                i.$slots[I.type] ? te(i.$slots, I.type, {
                  key: 0,
                  text: I.text,
                  value: t[I.type]
                }) : z("", !0),
                i.$slots[I.type] ? z("", !0) : (D(), V(de, { key: 1 }, [
                  et(Ne(I.text), 1)
                ], 64))
              ], 40, jl),
              ze($t, {
                name: f(P)(I.showSelectionGrid),
                css: f(g)
              }, {
                default: ie(() => [
                  I.showSelectionGrid ? (D(), ve(Ht, {
                    key: 0,
                    items: I.items,
                    "arrow-navigation": i.arrowNavigation,
                    "hide-navigation": i.hideNavigation,
                    "is-last": i.autoApply && !f(k).keepActionRow,
                    "skip-button-ref": !1,
                    config: i.config,
                    type: I.type,
                    "header-refs": [],
                    "esc-close": i.escClose,
                    "text-input": i.textInput,
                    onSelected: I.updateModelValue,
                    onToggle: I.toggle
                  }, Fe({
                    "button-icon": ie(() => [
                      i.$slots["calendar-icon"] ? te(i.$slots, "calendar-icon", { key: 0 }) : z("", !0),
                      i.$slots["calendar-icon"] ? z("", !0) : (D(), ve(f(Bt), { key: 1 }))
                    ]),
                    _: 2
                  }, [
                    i.$slots[`${I.type}-overlay-value`] ? {
                      name: "item",
                      fn: ie(({ item: u }) => [
                        te(i.$slots, `${I.type}-overlay-value`, {
                          text: u.text,
                          value: u.value
                        })
                      ]),
                      key: "0"
                    } : void 0,
                    i.$slots[`${I.type}-overlay`] ? {
                      name: "overlay",
                      fn: ie(() => [
                        te(i.$slots, `${I.type}-overlay`, Pe(He(re.value(I.type))))
                      ]),
                      key: "1"
                    } : void 0,
                    i.$slots[`${I.type}-overlay-header`] ? {
                      name: "header",
                      fn: ie(() => [
                        te(i.$slots, `${I.type}-overlay-header`, {
                          toggle: I.toggle
                        })
                      ]),
                      key: "2"
                    } : void 0
                  ]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "text-input", "onSelected", "onToggle"])) : z("", !0)
                ]),
                _: 2
              }, 1032, ["name", "css"])
            ], 64))), 128))
          ], 2),
          f(K)(f(c), e.instance) && i.vertical ? (D(), ve(Ct, {
            key: 1,
            "aria-label": (Z = f(l)) == null ? void 0 : Z.prevMonth,
            disabled: f(G)(!1),
            onActivate: o[2] || (o[2] = (I) => f(Y)(!1, !0))
          }, {
            default: ie(() => [
              i.$slots["arrow-up"] ? te(i.$slots, "arrow-up", { key: 0 }) : z("", !0),
              i.$slots["arrow-up"] ? z("", !0) : (D(), ve(f(Ln), { key: 1 }))
            ]),
            _: 3
          }, 8, ["aria-label", "disabled"])) : z("", !0),
          f(J)(f(c), e.instance) ? (D(), ve(Ct, {
            key: 2,
            ref: "rightIcon",
            disabled: f(G)(!0),
            "aria-label": (s = f(l)) == null ? void 0 : s.nextMonth,
            onActivate: o[3] || (o[3] = (I) => f(Y)(!0, !0)),
            onSetRef: o[4] || (o[4] = (I) => E(I, i.disableYearSelect ? 2 : 3))
          }, {
            default: ie(() => [
              i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? te(i.$slots, i.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : z("", !0),
              i.$slots[i.vertical ? "arrow-down" : "arrow-right"] ? z("", !0) : (D(), ve(In(i.vertical ? f(Un) : f(Hn)), { key: 1 }))
            ]),
            _: 3
          }, 8, ["disabled", "aria-label"])) : z("", !0)
        ], 64))
      ]);
    };
  }
}), Gl = ["aria-label"], Zl = {
  class: "dp__calendar_header",
  role: "row"
}, Ql = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, ql = /* @__PURE__ */ oe("div", { class: "dp__calendar_header_separator" }, null, -1), Xl = ["aria-label"], Jl = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, xl = { class: "dp__cell_inner" }, eo = ["aria-selected", "aria-disabled", "aria-label", "onClick", "onKeydown", "onMouseenter", "onMouseleave"], to = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DpCalendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...qe
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, { buildMultiLevelMatrix: r } = it(), { defaultedTransitions: l, defaultedConfig: c, defaultedAriaLabels: b, defaultedMultiCalendars: k } = Ae(t), P = X(null), g = X({
      bottom: "",
      left: "",
      transform: ""
    }), S = X([]), Y = X(null), G = X(!0), N = X(""), K = X({ startX: 0, endX: 0, startY: 0, endY: 0 }), J = X([]), h = X({ left: "50%" }), O = W(() => t.calendar ? t.calendar(t.mappedDates) : t.mappedDates), p = W(() => t.dayNames ? Array.isArray(t.dayNames) ? t.dayNames : t.dayNames(t.locale, +t.weekStart) : Nr(t.formatLocale, t.locale, +t.weekStart));
    je(() => {
      a("mount", { cmp: "calendar", refs: S }), c.value.noSwipe || Y.value && (Y.value.addEventListener("touchstart", x, { passive: !1 }), Y.value.addEventListener("touchend", v, { passive: !1 }), Y.value.addEventListener("touchmove", E, { passive: !1 })), t.monthChangeOnScroll && Y.value && Y.value.addEventListener("wheel", i, { passive: !1 });
    });
    const m = (s) => s ? t.vertical ? "vNext" : "next" : t.vertical ? "vPrevious" : "previous", C = (s, I) => {
      if (t.transitions) {
        const pe = We(xe(H(), t.month, t.year));
        N.value = Ie(We(xe(H(), s, I)), pe) ? l.value[m(!0)] : l.value[m(!1)], G.value = !1, st(() => {
          G.value = !0;
        });
      }
    }, j = W(
      () => ({
        [t.calendarClassName]: !!t.calendarClassName
      })
    ), re = W(() => (s) => {
      const I = Br(s);
      return {
        dp__marker_dot: I.type === "dot",
        dp__marker_line: I.type === "line"
      };
    }), ue = W(() => (s) => ye(s, P.value)), Q = W(() => ({
      dp__calendar: !0,
      dp__calendar_next: k.value.count > 0 && t.instance !== 0
    })), y = W(() => (s) => t.hideOffsetDates ? s.current : !0), w = async (s, I, pe) => {
      var u, B;
      if (a("set-hover-date", s), (B = (u = s.marker) == null ? void 0 : u.tooltip) != null && B.length) {
        const U = Se(S.value[I][pe]);
        if (U) {
          const { width: _, height: q } = U.getBoundingClientRect();
          P.value = s.value;
          let ce = { left: `${_ / 2}px` }, fe = -50;
          if (await st(), J.value[0]) {
            const { left: R, width: F } = J.value[0].getBoundingClientRect();
            R < 0 && (ce = { left: "0" }, fe = 0, h.value.left = `${_ / 2}px`), window.innerWidth < R + F && (ce = { right: "0" }, fe = 0, h.value.left = `${F - _ / 2}px`);
          }
          g.value = {
            bottom: `${q}px`,
            ...ce,
            transform: `translateX(${fe}%)`
          }, a("tooltip-open", s.marker);
        }
      }
    }, L = (s) => {
      P.value && (P.value = null, g.value = JSON.parse(JSON.stringify({ bottom: "", left: "", transform: "" })), a("tooltip-close", s.marker));
    }, x = (s) => {
      K.value.startX = s.changedTouches[0].screenX, K.value.startY = s.changedTouches[0].screenY;
    }, v = (s) => {
      K.value.endX = s.changedTouches[0].screenX, K.value.endY = s.changedTouches[0].screenY, M();
    }, E = (s) => {
      t.vertical && !t.inline && s.preventDefault();
    }, M = () => {
      const s = t.vertical ? "Y" : "X";
      Math.abs(K.value[`start${s}`] - K.value[`end${s}`]) > 10 && a("handle-swipe", K.value[`start${s}`] > K.value[`end${s}`] ? "right" : "left");
    }, A = (s, I, pe) => {
      s && (Array.isArray(S.value[I]) ? S.value[I][pe] = s : S.value[I] = [s]), t.arrowNavigation && r(S.value, "calendar");
    }, i = (s) => {
      t.monthChangeOnScroll && (s.preventDefault(), a("handle-scroll", s));
    }, o = (s) => {
      const I = s[0];
      return t.weekNumbers === "local" ? tr(I.value, { weekStartsOn: +t.weekStart }) : t.weekNumbers === "iso" ? nr(I.value) : typeof t.weekNumbers == "function" ? t.weekNumbers(I.value) : "";
    }, $ = (s, I) => {
      lt(s, c.value), a("select-date", I);
    }, Z = (s) => {
      lt(s, c.value);
    };
    return n({ triggerTransition: C }), (s, I) => {
      var pe;
      return D(), V("div", {
        class: he(Q.value)
      }, [
        oe("div", {
          ref_key: "calendarWrapRef",
          ref: Y,
          role: "grid",
          class: he(j.value),
          "aria-label": (pe = f(b)) == null ? void 0 : pe.calendarWrap
        }, [
          (D(), V(de, { key: 0 }, [
            oe("div", Zl, [
              s.weekNumbers ? (D(), V("div", Ql, Ne(s.weekNumName), 1)) : z("", !0),
              (D(!0), V(de, null, De(p.value, (u, B) => (D(), V("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: B
              }, [
                s.$slots["calendar-header"] ? te(s.$slots, "calendar-header", {
                  key: 0,
                  day: u,
                  index: B
                }) : z("", !0),
                s.$slots["calendar-header"] ? z("", !0) : (D(), V(de, { key: 1 }, [
                  et(Ne(u), 1)
                ], 64))
              ]))), 128))
            ]),
            ql,
            ze($t, {
              name: N.value,
              css: !!s.transitions
            }, {
              default: ie(() => {
                var u;
                return [
                  G.value ? (D(), V("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "rowgroup",
                    "aria-label": ((u = f(b)) == null ? void 0 : u.calendarDays) || void 0
                  }, [
                    (D(!0), V(de, null, De(O.value, (B, U) => (D(), V("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: U
                    }, [
                      s.weekNumbers ? (D(), V("div", Jl, [
                        oe("div", xl, Ne(o(B.days)), 1)
                      ])) : z("", !0),
                      (D(!0), V(de, null, De(B.days, (_, q) => {
                        var ce, fe, R;
                        return D(), V("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: !0,
                          ref: (F) => A(F, U, q),
                          key: q + U,
                          "aria-selected": _.classData.dp__active_date || _.classData.dp__range_start || _.classData.dp__range_start,
                          "aria-disabled": _.classData.dp__cell_disabled || void 0,
                          "aria-label": (fe = (ce = f(b)) == null ? void 0 : ce.day) == null ? void 0 : fe.call(ce, _),
                          tabindex: "0",
                          onClick: be((F) => $(F, _), ["prevent"]),
                          onKeydown: [
                            le((F) => s.$emit("select-date", _), ["enter"]),
                            le((F) => s.$emit("handle-space", _), ["space"])
                          ],
                          onMouseenter: (F) => w(_, U, q),
                          onMouseleave: (F) => L(_)
                        }, [
                          oe("div", {
                            class: he(["dp__cell_inner", _.classData])
                          }, [
                            s.$slots.day && y.value(_) ? te(s.$slots, "day", {
                              key: 0,
                              day: +_.text,
                              date: _.value
                            }) : z("", !0),
                            s.$slots.day ? z("", !0) : (D(), V(de, { key: 1 }, [
                              et(Ne(_.text), 1)
                            ], 64)),
                            _.marker && y.value(_) ? (D(), V(de, { key: 2 }, [
                              s.$slots.marker ? te(s.$slots, "marker", {
                                key: 0,
                                marker: _.marker,
                                day: +_.text,
                                date: _.value
                              }) : (D(), V("div", {
                                key: 1,
                                class: he(re.value(_.marker)),
                                style: Ze(_.marker.color ? { backgroundColor: _.marker.color } : {})
                              }, null, 6))
                            ], 64)) : z("", !0),
                            ue.value(_.value) ? (D(), V("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              ref_for: !0,
                              ref_key: "activeTooltip",
                              ref: J,
                              style: Ze(g.value)
                            }, [
                              (R = _.marker) != null && R.tooltip ? (D(), V("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: Z
                              }, [
                                (D(!0), V(de, null, De(_.marker.tooltip, (F, Me) => (D(), V("div", {
                                  key: Me,
                                  class: "dp__tooltip_text"
                                }, [
                                  s.$slots["marker-tooltip"] ? te(s.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: F,
                                    day: _.value
                                  }) : z("", !0),
                                  s.$slots["marker-tooltip"] ? z("", !0) : (D(), V(de, { key: 1 }, [
                                    oe("div", {
                                      class: "dp__tooltip_mark",
                                      style: Ze(F.color ? { backgroundColor: F.color } : {})
                                    }, null, 4),
                                    oe("div", null, Ne(F.text), 1)
                                  ], 64))
                                ]))), 128)),
                                oe("div", {
                                  class: "dp__arrow_bottom_tp",
                                  style: Ze(h.value)
                                }, null, 4)
                              ])) : z("", !0)
                            ], 4)) : z("", !0)
                          ], 2)
                        ], 40, eo);
                      }), 128))
                    ]))), 128))
                  ], 8, Xl)) : z("", !0)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 64))
        ], 10, Gl)
      ], 2);
    };
  }
}), ma = (e) => Array.isArray(e), no = (e, n, a, t) => {
  const r = X([]), { modelValue: l, calendars: c, time: b } = Ft(e, n), { defaultedMultiCalendars: k, defaultedStartTime: P } = Ae(e), { validateMonthYearInRange: g, isDisabled: S, isDateRangeAllowed: Y, checkMinMaxRange: G } = Tt(e), { updateTimeValues: N, getSetDateTime: K, setTime: J, assignStartTime: h, validateTime: O, disabledTimesConfig: p } = Va(e, b, l, t), m = W(
    () => (d) => c.value[d] ? c.value[d].month : 0
  ), C = W(
    () => (d) => c.value[d] ? c.value[d].year : 0
  ), j = (d, T, ae) => {
    var se, $e;
    c.value[d] || (c.value[d] = { month: 0, year: 0 }), c.value[d].month = ia(T) ? (se = c.value[d]) == null ? void 0 : se.month : T, c.value[d].year = ia(ae) ? ($e = c.value[d]) == null ? void 0 : $e.year : ae;
  }, re = () => {
    e.autoApply && n("select-date");
  };
  yt(l, (d, T) => {
    JSON.stringify(d) !== JSON.stringify(T) && y();
  }), je(() => {
    e.shadow || (l.value || ($(), P.value && h(P.value)), y(!0), e.focusStartDate && e.startDate && $());
  });
  const ue = W(() => {
    var d;
    return (d = e.flow) != null && d.length && !e.partialFlow ? e.flowStep === e.flow.length : !0;
  }), Q = () => {
    e.autoApply && ue.value && n("auto-apply", e.partialFlow);
  }, y = (d = !1) => {
    if (l.value)
      return Array.isArray(l.value) ? (r.value = l.value, M(d)) : L(l.value, d);
    if (k.value.count && d && !e.startDate)
      return w(H(), d);
  }, w = (d, T = !1) => {
    if ((!k.value.count || !k.value.static || T) && j(0, me(d), ge(d)), k.value.count)
      for (let ae = 1; ae < k.value.count; ae++) {
        const se = we(H(), { month: m.value(ae - 1), year: C.value(ae - 1) }), $e = Da(se, { months: 1 });
        c.value[ae] = { month: me($e), year: ge($e) };
      }
  }, L = (d, T) => {
    w(d), J("hours", Qe(d)), J("minutes", Je(d)), J("seconds", wt(d)), k.value.count && T && o();
  }, x = (d) => {
    if (k.value.count) {
      if (k.value.solo)
        return 0;
      const T = me(d[0]), ae = me(d[1]);
      return Math.abs(ae - T) < k.value.count ? 0 : 1;
    }
    return 1;
  }, v = (d, T) => {
    d[1] && e.showLastInRange ? w(d[x(d)], T) : w(d[0], T);
    const ae = (se, $e) => [
      se(d[0]),
      d[1] ? se(d[1]) : b[$e][1]
    ];
    J("hours", ae(Qe, "hours")), J("minutes", ae(Je, "minutes")), J("seconds", ae(wt, "seconds"));
  }, E = (d, T) => {
    if ((e.range || e.weekPicker) && !e.multiDates)
      return v(d, T);
    if (e.multiDates && T) {
      const ae = d[d.length - 1];
      return L(ae, T);
    }
  }, M = (d) => {
    const T = l.value;
    E(T, d), k.value.count && k.value.solo && o();
  }, A = (d, T) => {
    const ae = we(H(), { month: m.value(T), year: C.value(T) }), se = d < 0 ? vt(ae, 1) : Ot(ae, 1);
    g(me(se), ge(se), d < 0, e.preventMinMaxNavigation) && (j(T, me(se), ge(se)), k.value.count && !k.value.solo && i(T), a());
  }, i = (d) => {
    for (let T = d - 1; T >= 0; T--) {
      const ae = Ot(we(H(), { month: m.value(T + 1), year: C.value(T + 1) }), 1);
      j(T, me(ae), ge(ae));
    }
    for (let T = d + 1; T <= k.value.count - 1; T++) {
      const ae = vt(we(H(), { month: m.value(T - 1), year: C.value(T - 1) }), 1);
      j(T, me(ae), ge(ae));
    }
  }, o = () => {
    if (Array.isArray(l.value) && l.value.length === 2) {
      const d = H(
        H(l.value[1] ? l.value[1] : vt(l.value[0], 1))
      ), [T, ae] = [me(l.value[0]), ge(l.value[0])], [se, $e] = [me(l.value[1]), ge(l.value[1])];
      (T !== se || T === se && ae !== $e) && k.value.solo && j(1, me(d), ge(d));
    } else
      l.value && !Array.isArray(l.value) && (j(0, me(l.value), ge(l.value)), w(H()));
  }, $ = () => {
    e.startDate && (j(0, me(H(e.startDate)), ge(H(e.startDate))), k.value.count && i(0));
  }, Z = (d, T) => {
    e.monthChangeOnScroll && A(e.monthChangeOnScroll !== "inverse" ? -d.deltaY : d.deltaY, T);
  }, s = (d, T, ae = !1) => {
    e.monthChangeOnArrows && e.vertical === ae && I(d, T);
  }, I = (d, T) => {
    A(d === "right" ? -1 : 1, T);
  }, pe = (d) => e.markers.find((T) => ye(da(d.value), da(T.date))), u = (d, T) => {
    switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
      case "prepend":
        return [!0, !1];
      case "center":
        return [d == 0, !0];
      case "fair":
        return [d == 0 || T > d, !0];
      case "append":
        return [!1, !1];
      default:
        return [!1, !1];
    }
  }, B = (d, T, ae, se) => {
    if (e.sixWeeks && d.length < 6) {
      const $e = 6 - d.length, tt = (T.getDay() + 7 - se) % 7, Lt = 6 - (ae.getDay() + 7 - se) % 7, [Pt, fn] = u(tt, Lt);
      for (let ut = 1; ut <= $e; ut++)
        if (fn ? !!(ut % 2) == Pt : Pt) {
          const Ut = d[0].days[0], vn = U(ct(Ut.value, -7), me(T));
          d.unshift({ days: vn });
        } else {
          const Ut = d[d.length - 1], vn = Ut.days[Ut.days.length - 1], Ua = U(ct(vn.value, 1), me(T));
          d.push({ days: Ua });
        }
    }
    return d;
  }, U = (d, T) => {
    const ae = H(d), se = [];
    for (let $e = 0; $e < 7; $e++) {
      const tt = ct(ae, $e), St = me(tt) !== T;
      se.push({
        text: e.hideOffsetDates && St ? "" : tt.getDate(),
        value: tt,
        current: !St,
        classData: {}
      });
    }
    return se;
  }, _ = (d, T) => {
    const ae = [], se = H(Ue(new Date(T, d), e.timezone)), $e = H(Ue(new Date(T, d + 1, 0), e.timezone)), tt = e.weekStart, St = ba(se, { weekStartsOn: tt }), Lt = (Pt) => {
      const fn = U(Pt, d);
      if (ae.push({ days: fn }), !ae[ae.length - 1].days.some(
        (ut) => ye(We(ut.value), We($e))
      )) {
        const ut = ct(Pt, 7);
        Lt(ut);
      }
    };
    return Lt(St), B(ae, se, $e, tt);
  }, q = (d) => (l.value = Zt(H(d.value), e.timezone, e.weekStart), Q()), ce = (d) => {
    const T = ot(H(d.value), b.hours, b.minutes, Vt());
    e.multiDates ? tn(T, l, e.multiDatesLimit) : l.value = T, t(), st().then(() => {
      Q();
    });
  }, fe = (d) => e.noDisabledRange ? Ya(r.value[0], d).some((ae) => S(ae)) : !1, R = () => {
    r.value = l.value ? l.value.slice() : [], r.value.length === 2 && !(e.fixedStart || e.fixedEnd) && (r.value = []);
  }, F = (d, T) => {
    const ae = [H(d.value), ct(H(d.value), +e.autoRange)];
    Y(ae) && (T && Me(d.value), r.value = ae);
  }, Me = (d) => {
    const T = me(H(d)), ae = ge(H(d));
    if (j(0, T, ae), k.value.count > 0)
      for (let se = 1; se < k.value.count; se++) {
        const $e = Lr(
          we(H(d), { year: m.value(se - 1), month: C.value(se - 1) })
        );
        j(se, $e.month, $e.year);
      }
  }, ee = (d) => Array.isArray(l.value) && l.value.length === 2 ? e.fixedStart && (Ie(d, l.value[0]) || ye(d, l.value[0])) ? [l.value[0], d] : e.fixedEnd && (Re(d, l.value[1]) || ye(d, l.value[1])) ? [d, l.value[1]] : (n("invalid-fixed-range", d), l.value) : [], Le = (d) => {
    fe(d.value) || !G(d.value, l.value, e.fixedStart ? 0 : 1) || (r.value = ee(H(d.value)));
  }, _e = (d, T) => {
    if (R(), e.autoRange)
      return F(d, T);
    if (e.fixedStart || e.fixedEnd)
      return Le(d);
    r.value[0] ? G(H(d.value), l.value) && !fe(d.value) ? Re(H(d.value), H(r.value[0])) ? (r.value.unshift(H(d.value)), n("range-end", r.value[0])) : (r.value[1] = H(d.value), n("range-end", r.value[1])) : e.autoApply && n("auto-apply-invalid", d.value) : (r.value[0] = H(d.value), n("range-start", r.value[0]));
  }, Vt = (d = !0) => e.enableSeconds ? Array.isArray(b.seconds) ? d ? b.seconds[0] : b.seconds[1] : b.seconds : 0, At = (d) => {
    r.value[d] = ot(
      r.value[d],
      b.hours[d],
      b.minutes[d],
      Vt(d !== 1)
    );
  }, an = () => {
    var d, T;
    r.value[0] && r.value[1] && +((d = r.value) == null ? void 0 : d[0]) > +((T = r.value) == null ? void 0 : T[1]) && (r.value.reverse(), n("range-start", r.value[0]), n("range-end", r.value[1]));
  }, rn = () => {
    r.value.length && (r.value[0] && !r.value[1] ? At(0) : (At(0), At(1), t()), an(), l.value = r.value.slice(), nn(r.value, n, e.autoApply, e.modelAuto));
  }, ln = (d, T = !1) => {
    if (!(S(d.value) || !d.current && e.hideOffsetDates)) {
      if (e.weekPicker)
        return q(d);
      if (!e.range)
        return ce(d);
      ma(b.hours) && ma(b.minutes) && !e.multiDates && (_e(d, T), rn());
    }
  }, on = (d, T) => {
    var se;
    j(d, T.month, T.year), k.value.count && !k.value.solo && i(d), n("update-month-year", { instance: d, month: T.month, year: T.year }), a(k.value.solo ? d : void 0);
    const ae = (se = e.flow) != null && se.length ? e.flow[e.flowStep] : void 0;
    !T.fromNav && (ae === Xe.month || ae === Xe.year) && t();
  }, sn = (d, T) => {
    Array.isArray(d) && d.length <= 2 && e.range ? l.value = d.map((ae) => Ue(H(ae), T ? void 0 : e.timezone)) : Array.isArray(d) || (l.value = Ue(H(d), T ? void 0 : e.timezone)), re(), e.multiCalendars && st().then(() => y(!0));
  }, un = () => {
    e.range ? l.value && Array.isArray(l.value) && l.value[0] ? l.value = Re(H(), l.value[0]) ? [H(), l.value[0]] : [l.value[0], H()] : l.value = [H()] : l.value = H(), re();
  }, dn = () => {
    if (Array.isArray(l.value))
      if (e.multiDates) {
        const d = cn();
        l.value[l.value.length - 1] = K(d);
      } else
        l.value = l.value.map((d, T) => d && K(d, T));
    else
      l.value = K(l.value);
    n("time-update");
  }, cn = () => Array.isArray(l.value) && l.value.length ? l.value[l.value.length - 1] : null;
  return {
    calendars: c,
    modelValue: l,
    month: m,
    year: C,
    time: b,
    disabledTimesConfig: p,
    validateTime: O,
    getCalendarDays: _,
    getMarker: pe,
    handleScroll: Z,
    handleSwipe: I,
    handleArrow: s,
    selectDate: ln,
    updateMonthYear: on,
    presetDate: sn,
    selectCurrentDate: un,
    updateTime: (d, T = !0, ae = !1) => {
      N(d, T, ae, dn);
    }
  };
}, ao = { key: 0 }, ro = /* @__PURE__ */ Oe({
  __name: "DatePicker",
  props: {
    ...qe
  },
  emits: [
    "tooltip-open",
    "tooltip-close",
    "mount",
    "update:internal-model-value",
    "update-flow-step",
    "reset-flow",
    "auto-apply",
    "focus-menu",
    "select-date",
    "range-start",
    "range-end",
    "invalid-fixed-range",
    "time-update",
    "am-pm-change",
    "time-picker-open",
    "time-picker-close",
    "recalculate-position",
    "update-month-year",
    "auto-apply-invalid"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, {
      calendars: r,
      month: l,
      year: c,
      modelValue: b,
      time: k,
      disabledTimesConfig: P,
      validateTime: g,
      getCalendarDays: S,
      getMarker: Y,
      handleArrow: G,
      handleScroll: N,
      handleSwipe: K,
      selectDate: J,
      updateMonthYear: h,
      presetDate: O,
      selectCurrentDate: p,
      updateTime: m
    } = no(t, a, i, o), C = ht(), { setHoverDate: j, getDayClassData: re, clearHoverDate: ue } = ol(b, t), { defaultedMultiCalendars: Q } = Ae(t), y = X([]), w = X([]), L = X(null), x = Ve(C, "calendar"), v = Ve(C, "monthYear"), E = Ve(C, "timePicker"), M = (u) => {
      t.shadow || a("mount", u);
    };
    yt(
      r,
      () => {
        t.shadow || setTimeout(() => {
          a("recalculate-position");
        }, 0);
      },
      { deep: !0 }
    );
    const A = W(() => (u) => S(l.value(u), c.value(u)).map((B) => ({
      ...B,
      days: B.days.map((U) => (U.marker = Y(U), U.classData = re(U), U))
    })));
    function i(u) {
      var B;
      u || u === 0 ? (B = w.value[u]) == null || B.triggerTransition(l.value(u), c.value(u)) : w.value.forEach((U, _) => U.triggerTransition(l.value(_), c.value(_)));
    }
    function o() {
      a("update-flow-step");
    }
    const $ = (u, B = !1) => {
      J(u, B), t.spaceConfirm && a("select-date");
    };
    return n({
      clearHoverDate: ue,
      presetDate: O,
      selectCurrentDate: p,
      toggleMonthPicker: (u, B, U = 0) => {
        var _;
        (_ = y.value[U]) == null || _.toggleMonthPicker(u, B);
      },
      toggleYearPicker: (u, B, U = 0) => {
        var _;
        (_ = y.value[U]) == null || _.toggleYearPicker(u, B);
      },
      toggleTimePicker: (u, B, U) => {
        var _;
        (_ = L.value) == null || _.toggleTimePicker(u, B, U);
      },
      handleArrow: G,
      updateMonthYear: h,
      getSidebarProps: () => ({
        modelValue: b,
        month: l,
        year: c,
        time: k,
        updateTime: m,
        updateMonthYear: h,
        selectDate: J,
        presetDate: O
      })
    }), (u, B) => (D(), V(de, null, [
      ze(en, {
        "multi-calendars": f(Q).count
      }, {
        default: ie(({ instance: U, index: _ }) => [
          u.disableMonthYearSelect ? z("", !0) : (D(), ve(Kl, Ye({
            key: 0,
            ref: (q) => {
              q && (y.value[_] = q);
            },
            months: f(Sa)(u.formatLocale, u.locale, u.monthNameFormat),
            years: f(Kn)(u.yearRange, u.reverseYears),
            month: f(l)(U),
            year: f(c)(U),
            instance: U
          }, u.$props, {
            onMount: B[0] || (B[0] = (q) => M(f(gt).header)),
            onResetFlow: B[1] || (B[1] = (q) => u.$emit("reset-flow")),
            onUpdateMonthYear: (q) => f(h)(U, q),
            onOverlayClosed: B[2] || (B[2] = (q) => u.$emit("focus-menu"))
          }), Fe({ _: 2 }, [
            De(f(v), (q, ce) => ({
              name: q,
              fn: ie((fe) => [
                te(u.$slots, q, Pe(He(fe)))
              ])
            }))
          ]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])),
          ze(to, Ye({
            ref: (q) => {
              q && (w.value[_] = q);
            },
            "mapped-dates": A.value(U),
            month: f(l)(U),
            year: f(c)(U),
            instance: U
          }, u.$props, {
            onSelectDate: (q) => f(J)(q, U !== 1),
            onHandleSpace: (q) => $(q, U !== 1),
            onSetHoverDate: B[3] || (B[3] = (q) => f(j)(q)),
            onHandleScroll: (q) => f(N)(q, U),
            onHandleSwipe: (q) => f(K)(q, U),
            onMount: B[4] || (B[4] = (q) => M(f(gt).calendar)),
            onResetFlow: B[5] || (B[5] = (q) => u.$emit("reset-flow")),
            onTooltipOpen: B[6] || (B[6] = (q) => u.$emit("tooltip-open", q)),
            onTooltipClose: B[7] || (B[7] = (q) => u.$emit("tooltip-close", q))
          }), Fe({ _: 2 }, [
            De(f(x), (q, ce) => ({
              name: q,
              fn: ie((fe) => [
                te(u.$slots, q, Pe(He({ ...fe })))
              ])
            }))
          ]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
        ]),
        _: 3
      }, 8, ["multi-calendars"]),
      u.enableTimePicker ? (D(), V("div", ao, [
        u.$slots["time-picker"] ? te(u.$slots, "time-picker", Pe(Ye({ key: 0 }, { time: f(k), updateTime: f(m) }))) : (D(), ve(Ha, Ye({
          key: 1,
          ref_key: "timePickerRef",
          ref: L
        }, u.$props, {
          hours: f(k).hours,
          minutes: f(k).minutes,
          seconds: f(k).seconds,
          "internal-model-value": u.internalModelValue,
          "disabled-times-config": f(P),
          "validate-time": f(g),
          onMount: B[8] || (B[8] = (U) => M(f(gt).timePicker)),
          "onUpdate:hours": B[9] || (B[9] = (U) => f(m)(U)),
          "onUpdate:minutes": B[10] || (B[10] = (U) => f(m)(U, !1)),
          "onUpdate:seconds": B[11] || (B[11] = (U) => f(m)(U, !1, !0)),
          onResetFlow: B[12] || (B[12] = (U) => u.$emit("reset-flow")),
          onOverlayClosed: B[13] || (B[13] = (U) => u.$emit("time-picker-close")),
          onOverlayOpened: B[14] || (B[14] = (U) => u.$emit("time-picker-open", U)),
          onAmPmChange: B[15] || (B[15] = (U) => u.$emit("am-pm-change", U))
        }), Fe({ _: 2 }, [
          De(f(E), (U, _) => ({
            name: U,
            fn: ie((q) => [
              te(u.$slots, U, Pe(He(q)))
            ])
          }))
        ]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))
      ])) : z("", !0)
    ], 64));
  }
}), lo = (e, n) => {
  const a = X(), { defaultedMultiCalendars: t, defaultedConfig: r } = Ae(e), { modelValue: l, year: c, month: b, calendars: k } = Ft(e, n), { isDisabled: P } = Tt(e), { selectYear: g, groupedYears: S, showYearPicker: Y, isDisabled: G, toggleYearPicker: N, handleYearSelect: K, handleYear: J } = Fa({
    modelValue: l,
    multiCalendars: t,
    calendars: k,
    month: b,
    year: c,
    props: e,
    emit: n
  }), h = (y, w) => [y, w].map((L) => rt(L, "MMMM", { locale: e.formatLocale })).join("-"), O = W(() => (y) => l.value ? Array.isArray(l.value) ? l.value.some((w) => qn(y, w)) : qn(l.value, y) : !1), p = (y) => {
    if (e.range) {
      if (Array.isArray(l.value)) {
        const w = ye(y, l.value[0]) || ye(y, l.value[1]);
        return Xt(l.value, a.value, y) && !w;
      }
      return !1;
    }
    return !1;
  }, m = W(() => (y) => {
    const w = we(/* @__PURE__ */ new Date(), { year: c.value(y) });
    return ar({
      start: rr(w),
      end: lr(w)
    }).map((L) => {
      const x = or(L), v = Xn(L), E = P(L), M = p(x);
      return {
        text: h(x, v),
        value: x,
        active: O.value(x),
        disabled: E,
        isBetween: M
      };
    });
  }), C = (y) => {
    tn(y, l, e.multiDatesLimit), n("auto-apply", !0);
  }, j = (y) => {
    const w = Gn(l, y, n);
    nn(w, n, e.autoApply, e.modelAuto);
  }, re = (y) => {
    l.value = y, n("auto-apply");
  };
  return {
    defaultedConfig: r,
    defaultedMultiCalendars: t,
    groupedYears: S,
    year: c,
    isDisabled: G,
    quarters: m,
    showYearPicker: Y,
    setHoverDate: (y) => {
      a.value = y;
    },
    selectYear: g,
    selectQuarter: (y, w, L) => {
      if (!L)
        return k.value[w].month = me(Xn(y)), e.multiDates ? C(y) : e.range ? j(y) : re(y);
    },
    toggleYearPicker: N,
    handleYearSelect: K,
    handleYear: J
  };
}, oo = { class: "dp--quarter-items" }, so = ["disabled", "onClick", "onMouseover"], io = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "QuarterPicker",
  props: {
    ...qe
  },
  emits: [
    "update:internal-model-value",
    "reset-flow",
    "overlay-closed",
    "auto-apply",
    "range-start",
    "range-end"
  ],
  setup(e, { emit: n }) {
    const a = e, t = ht(), r = Ve(t, "yearMode"), {
      defaultedMultiCalendars: l,
      defaultedConfig: c,
      groupedYears: b,
      year: k,
      isDisabled: P,
      quarters: g,
      showYearPicker: S,
      setHoverDate: Y,
      selectQuarter: G,
      toggleYearPicker: N,
      handleYearSelect: K,
      handleYear: J
    } = lo(a, n);
    return (h, O) => (D(), ve(en, {
      "multi-calendars": f(l).count,
      stretch: ""
    }, {
      default: ie(({ instance: p }) => [
        oe("div", {
          class: "dp-quarter-picker-wrap",
          style: Ze({ minHeight: `${f(c).modeHeight}px` })
        }, [
          oe("div", null, [
            ze(Ea, Ye(h.$props, {
              items: f(b)(p),
              instance: p,
              "show-year-picker": f(S)[p],
              year: f(k)(p),
              "is-disabled": (m) => f(P)(p, m),
              onHandleYear: (m) => f(J)(p, m),
              onYearSelect: (m) => f(K)(m, p),
              onToggleYearPicker: (m) => f(N)(p, m == null ? void 0 : m.flow, m == null ? void 0 : m.show)
            }), Fe({ _: 2 }, [
              De(f(r), (m, C) => ({
                name: m,
                fn: ie((j) => [
                  te(h.$slots, m, Pe(He(j)))
                ])
              }))
            ]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])
          ]),
          oe("div", oo, [
            (D(!0), V(de, null, De(f(g)(p), (m, C) => (D(), V("div", { key: C }, [
              oe("button", {
                type: "button",
                class: he(["dp--qr-btn", {
                  "dp--qr-btn-active": m.active,
                  "dp--qr-btn-between": m.isBetween,
                  "dp--qr-btn-disabled": m.disabled
                }]),
                disabled: m.disabled,
                onClick: (j) => f(G)(m.value, p, m.disabled),
                onMouseover: (j) => f(Y)(m.value)
              }, [
                h.$slots.quarter ? te(h.$slots, "quarter", {
                  key: 0,
                  value: m.value,
                  text: m.text
                }) : (D(), V(de, { key: 1 }, [
                  et(Ne(m.text), 1)
                ], 64))
              ], 42, so)
            ]))), 128))
          ])
        ], 4)
      ]),
      _: 3
    }, 8, ["multi-calendars"]));
  }
}), uo = ["id", "onKeydown"], co = {
  key: 0,
  class: "dp__sidebar_left"
}, fo = {
  key: 1,
  class: "dp--preset-dates"
}, vo = ["onClick", "onKeydown"], mo = {
  key: 2,
  class: "dp__sidebar_right"
}, go = {
  key: 3,
  class: "dp__action_extra"
}, ga = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "DatepickerMenu",
  props: {
    ...xt,
    shadow: { type: Boolean, default: !1 },
    openOnTop: { type: Boolean, default: !1 },
    internalModelValue: { type: [Date, Array], default: null },
    arrMapValues: { type: Object, default: () => ({}) }
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end",
    "auto-apply-invalid"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, r = W(() => {
      const { openOnTop: R, ...F } = t;
      return {
        ...F,
        flowStep: re.value
      };
    }), { setMenuFocused: l, setShiftKey: c, control: b } = Ba(), k = ht(), { defaultedTextInput: P, defaultedInline: g, defaultedConfig: S } = Ae(t), Y = X(null), G = X(0), N = X(null), K = X(null), J = X(!1), h = X(null);
    je(() => {
      if (!t.shadow) {
        J.value = !0, O(), window.addEventListener("resize", O);
        const R = Se(N);
        if (R && !P.value.enabled && !g.value.enabled && (l(!0), L()), R) {
          const F = (Me) => {
            S.value.allowPreventDefault && Me.preventDefault(), lt(Me, S.value, !0);
          };
          R.addEventListener("pointerdown", F), R.addEventListener("mousedown", F);
        }
      }
    }), Nn(() => {
      window.removeEventListener("resize", O);
    });
    const O = () => {
      const R = Se(K);
      R && (G.value = R.getBoundingClientRect().width);
    }, { arrowRight: p, arrowLeft: m, arrowDown: C, arrowUp: j } = it(), { flowStep: re, updateFlowStep: ue, childMount: Q, resetFlow: y } = sl(t, a, h), w = W(() => t.monthPicker ? $l : t.yearPicker ? Al : t.timePicker ? zl : t.quarterPicker ? io : ro), L = () => {
      const R = Se(N);
      R && R.focus({ preventScroll: !0 });
    }, x = W(() => {
      var R;
      return ((R = h.value) == null ? void 0 : R.getSidebarProps()) || {};
    }), v = () => {
      t.openOnTop && a("recalculate-position");
    }, E = Ve(k, "action"), M = W(() => t.monthPicker || t.yearPicker ? Ve(k, "monthYear") : t.timePicker ? Ve(k, "timePicker") : Ve(k, "shared")), A = W(() => t.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), i = W(() => ({
      dp__menu_disabled: t.disabled,
      dp__menu_readonly: t.readonly
    })), o = W(
      () => ({
        dp__menu: !0,
        dp__menu_index: !g.value.enabled,
        dp__relative: g.value.enabled,
        [t.menuClassName]: !!t.menuClassName
      })
    ), $ = (R) => {
      lt(R, S.value, !0);
    }, Z = () => {
      t.escClose && a("close-picker");
    }, s = (R) => {
      if (t.arrowNavigation) {
        if (R === "up")
          return j();
        if (R === "down")
          return C();
        if (R === "left")
          return m();
        if (R === "right")
          return p();
      } else
        R === "left" || R === "up" ? U("handleArrow", "left", 0, R === "up") : U("handleArrow", "right", 0, R === "down");
    }, I = (R) => {
      c(R.shiftKey), !t.disableMonthYearSelect && R.code === "Tab" && R.target.classList.contains("dp__menu") && b.value.shiftKeyInMenu && (R.preventDefault(), lt(R, S.value, !0), a("close-picker"));
    }, pe = () => {
      L(), a("time-picker-close");
    }, u = (R) => {
      var F, Me, ee;
      (F = h.value) == null || F.toggleTimePicker(!1, !1), (Me = h.value) == null || Me.toggleMonthPicker(!1, !1, R), (ee = h.value) == null || ee.toggleYearPicker(!1, !1, R);
    }, B = (R, F = 0) => {
      var Me, ee, Le;
      return R === "month" ? (Me = h.value) == null ? void 0 : Me.toggleMonthPicker(!1, !0, F) : R === "year" ? (ee = h.value) == null ? void 0 : ee.toggleYearPicker(!1, !0, F) : R === "time" ? (Le = h.value) == null ? void 0 : Le.toggleTimePicker(!0, !1) : u(F);
    }, U = (R, ...F) => {
      var Me, ee;
      (Me = h.value) != null && Me[R] && ((ee = h.value) == null || ee[R](...F));
    }, _ = () => {
      U("selectCurrentDate");
    }, q = (R, F) => {
      U("presetDate", R, F);
    }, ce = () => {
      U("clearHoverDate");
    };
    return n({
      updateMonthYear: (R, F) => {
        U("updateMonthYear", R, F);
      },
      switchView: B
    }), (R, F) => {
      var Me;
      return D(), V("div", {
        id: R.uid ? `dp-menu-${R.uid}` : void 0,
        tabindex: "0",
        ref_key: "dpMenuRef",
        ref: N,
        role: "dialog",
        class: he(o.value),
        onMouseleave: ce,
        onClick: $,
        onKeydown: [
          le(Z, ["esc"]),
          F[16] || (F[16] = le(be((ee) => s("left"), ["prevent"]), ["left"])),
          F[17] || (F[17] = le(be((ee) => s("up"), ["prevent"]), ["up"])),
          F[18] || (F[18] = le(be((ee) => s("down"), ["prevent"]), ["down"])),
          F[19] || (F[19] = le(be((ee) => s("right"), ["prevent"]), ["right"])),
          I
        ]
      }, [
        (R.disabled || R.readonly) && f(g).enabled ? (D(), V("div", {
          key: 0,
          class: he(i.value)
        }, null, 2)) : z("", !0),
        !f(g).enabled && !R.teleportCenter ? (D(), V("div", {
          key: 1,
          class: he(A.value)
        }, null, 2)) : z("", !0),
        oe("div", {
          ref_key: "innerMenuRef",
          ref: K,
          class: he({
            dp__menu_content_wrapper: ((Me = R.presetDates) == null ? void 0 : Me.length) || !!R.$slots["left-sidebar"] || !!R.$slots["right-sidebar"]
          }),
          style: Ze({ "--dp-menu-width": `${G.value}px` })
        }, [
          R.$slots["left-sidebar"] ? (D(), V("div", co, [
            te(R.$slots, "left-sidebar", Pe(He(x.value)))
          ])) : z("", !0),
          R.presetDates.length ? (D(), V("div", fo, [
            (D(!0), V(de, null, De(R.presetDates, (ee, Le) => (D(), V(de, { key: Le }, [
              ee.slot ? te(R.$slots, ee.slot, {
                key: 0,
                presetDate: q,
                label: ee.label,
                value: ee.value
              }) : (D(), V("button", {
                key: 1,
                type: "button",
                style: Ze(ee.style || {}),
                class: "dp__btn dp--preset-range",
                onClick: be((_e) => q(ee.value, ee.noTz), ["prevent"]),
                onKeydown: [
                  le(be((_e) => q(ee.value, ee.noTz), ["prevent"]), ["enter"]),
                  le(be((_e) => q(ee.value, ee.noTz), ["prevent"]), ["space"])
                ]
              }, Ne(ee.label), 45, vo))
            ], 64))), 128))
          ])) : z("", !0),
          oe("div", {
            class: "dp__instance_calendar",
            ref_key: "calendarWrapperRef",
            ref: Y,
            role: "document"
          }, [
            (D(), ve(In(w.value), Ye({
              ref_key: "dynCmpRef",
              ref: h
            }, r.value, {
              "flow-step": f(re),
              onMount: f(Q),
              onUpdateFlowStep: f(ue),
              onResetFlow: f(y),
              onFocusMenu: L,
              onSelectDate: F[0] || (F[0] = (ee) => R.$emit("select-date")),
              onTooltipOpen: F[1] || (F[1] = (ee) => R.$emit("tooltip-open", ee)),
              onTooltipClose: F[2] || (F[2] = (ee) => R.$emit("tooltip-close", ee)),
              onAutoApply: F[3] || (F[3] = (ee) => R.$emit("auto-apply", ee)),
              onRangeStart: F[4] || (F[4] = (ee) => R.$emit("range-start", ee)),
              onRangeEnd: F[5] || (F[5] = (ee) => R.$emit("range-end", ee)),
              onInvalidFixedRange: F[6] || (F[6] = (ee) => R.$emit("invalid-fixed-range", ee)),
              onTimeUpdate: F[7] || (F[7] = (ee) => R.$emit("time-update")),
              onAmPmChange: F[8] || (F[8] = (ee) => R.$emit("am-pm-change", ee)),
              onTimePickerOpen: F[9] || (F[9] = (ee) => R.$emit("time-picker-open", ee)),
              onTimePickerClose: pe,
              onRecalculatePosition: v,
              onUpdateMonthYear: F[10] || (F[10] = (ee) => R.$emit("update-month-year", ee)),
              onAutoApplyInvalid: F[11] || (F[11] = (ee) => R.$emit("auto-apply-invalid", ee)),
              "onUpdate:internalModelValue": F[12] || (F[12] = (ee) => R.$emit("update:internal-model-value", ee))
            }), Fe({ _: 2 }, [
              De(M.value, (ee, Le) => ({
                name: ee,
                fn: ie((_e) => [
                  te(R.$slots, ee, Pe(He({ ..._e })))
                ])
              }))
            ]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))
          ], 512),
          R.$slots["right-sidebar"] ? (D(), V("div", mo, [
            te(R.$slots, "right-sidebar", Pe(He(x.value)))
          ])) : z("", !0),
          R.$slots["action-extra"] ? (D(), V("div", go, [
            R.$slots["action-extra"] ? te(R.$slots, "action-extra", {
              key: 0,
              selectCurrentDate: _
            }) : z("", !0)
          ])) : z("", !0)
        ], 6),
        !R.autoApply || f(S).keepActionRow ? (D(), ve(gl, Ye({
          key: 2,
          "menu-mount": J.value
        }, r.value, {
          "calendar-width": G.value,
          onClosePicker: F[13] || (F[13] = (ee) => R.$emit("close-picker")),
          onSelectDate: F[14] || (F[14] = (ee) => R.$emit("select-date")),
          onInvalidSelect: F[15] || (F[15] = (ee) => R.$emit("invalid-select")),
          onSelectNow: _
        }), Fe({ _: 2 }, [
          De(f(E), (ee, Le) => ({
            name: ee,
            fn: ie((_e) => [
              te(R.$slots, ee, Pe(He({ ..._e })))
            ])
          }))
        ]), 1040, ["menu-mount", "calendar-width"])) : z("", !0)
      ], 42, uo);
    };
  }
}), yo = typeof window < "u" ? window : void 0, Tn = () => {
}, ho = (e) => ja() ? (Ka(e), !0) : !1, po = (e, n, a, t) => {
  if (!e)
    return Tn;
  let r = Tn;
  const l = yt(
    () => f(e),
    (b) => {
      r(), b && (b.addEventListener(n, a, t), r = () => {
        b.removeEventListener(n, a, t), r = Tn;
      });
    },
    { immediate: !0, flush: "post" }
  ), c = () => {
    l(), r();
  };
  return ho(c), c;
}, bo = (e, n, a, t = {}) => {
  const { window: r = yo, event: l = "pointerdown" } = t;
  return r ? po(r, l, (b) => {
    const k = Se(e), P = Se(n);
    !k || !P || k === b.target || b.composedPath().includes(k) || b.composedPath().includes(P) || a(b);
  }, { passive: !0 }) : void 0;
}, ko = /* @__PURE__ */ Oe({
  compatConfig: {
    MODE: 3
  },
  __name: "VueDatePicker",
  props: {
    ...xt
  },
  emits: [
    "update:model-value",
    "update:model-timezone-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close",
    "time-picker-open",
    "time-picker-close",
    "am-pm-change",
    "range-start",
    "range-end"
  ],
  setup(e, { expose: n, emit: a }) {
    const t = e, r = ht(), l = X(!1), c = Qt(t, "modelValue"), b = Qt(t, "timezone"), k = X(null), P = X(null), g = X(null), S = X(!1), Y = X(null), { setMenuFocused: G, setShiftKey: N } = Ba(), { clearArrowNav: K } = it(), { mapDatesArrToMap: J, validateDate: h, isValidTime: O } = Tt(t), { defaultedTransitions: p, defaultedTextInput: m, defaultedInline: C, defaultedConfig: j } = Ae(t), { menuTransition: re, showTransition: ue } = Et(p);
    je(() => {
      $(t.modelValue), st().then(() => {
        C.value.enabled || (M(Y.value).addEventListener("scroll", U), window.addEventListener("resize", _));
      }), C.value.enabled && (l.value = !0);
    });
    const Q = W(() => J());
    Nn(() => {
      if (!C.value.enabled) {
        const ne = M(Y.value);
        ne && ne.removeEventListener("scroll", U), window.removeEventListener("resize", _);
      }
    });
    const y = Ve(r, "all", t.presetDates), w = Ve(r, "input");
    yt(
      [c, b],
      () => {
        $(c.value);
      },
      { deep: !0 }
    );
    const { openOnTop: L, menuStyle: x, xCorrect: v, setMenuPosition: E, getScrollableParent: M, shadowRender: A } = al({
      menuRef: k,
      menuRefInner: P,
      inputRef: g,
      pickerWrapperRef: Y,
      inline: C,
      emit: a,
      props: t,
      slots: r
    }), {
      inputValue: i,
      internalModelValue: o,
      parseExternalModelValue: $,
      emitModelValue: Z,
      formatInputValue: s,
      checkBeforeEmit: I
    } = tl(a, t, S), pe = W(
      () => ({
        dp__main: !0,
        dp__theme_dark: t.dark,
        dp__theme_light: !t.dark,
        dp__flex_display: C.value.enabled,
        dp__flex_display_with_input: C.value.input
      })
    ), u = W(() => t.dark ? "dp__theme_dark" : "dp__theme_light"), B = W(() => t.teleport ? {
      to: typeof t.teleport == "boolean" ? "body" : t.teleport,
      disabled: C.value.enabled
    } : { class: "dp__outer_menu_wrap" }), U = () => {
      l.value && (j.value.closeOnScroll ? _e() : E());
    }, _ = () => {
      l.value && E();
    }, q = () => {
      !t.disabled && !t.readonly && (A(ga, t), E(!1), l.value = !0, l.value && a("open"), l.value || Le(), $(t.modelValue));
    }, ce = () => {
      var ne;
      i.value = "", Le(), (ne = g.value) == null || ne.setParsedDate(null), a("update:model-value", null), a("update:model-timezone-value", null), a("cleared"), j.value.closeOnClearValue && _e();
    }, fe = () => {
      const ne = o.value;
      return !ne || !Array.isArray(ne) && h(ne) ? !0 : Array.isArray(ne) ? ne.length === 2 && h(ne[0]) && h(ne[1]) ? !0 : t.partialRange && !t.timePicker ? h(ne[0]) : !1 : !1;
    }, R = () => {
      I() && fe() ? (Z(), _e()) : a("invalid-select", o.value);
    }, F = (ne) => {
      Me(), Z(), j.value.closeOnAutoApply && !ne && _e();
    }, Me = () => {
      g.value && m.value.enabled && g.value.setParsedDate(o.value);
    }, ee = (ne = !1) => {
      t.autoApply && O(o.value) && fe() && (t.range && Array.isArray(o.value) ? (t.partialRange || o.value.length === 2) && F(ne) : F(ne));
    }, Le = () => {
      m.value.enabled || (o.value = null);
    }, _e = () => {
      C.value.enabled || (l.value && (l.value = !1, v.value = !1, G(!1), N(!1), K(), a("closed"), i.value && $(c.value)), Le(), a("blur"));
    }, Vt = (ne, d) => {
      if (!ne) {
        o.value = null;
        return;
      }
      const T = Array.isArray(ne) ? !ne.some((se) => !h(se)) : h(ne), ae = O(ne);
      T && ae && (o.value = ne, d && (R(), a("text-submit")));
    }, At = () => {
      t.autoApply && O(o.value) && Z(), Me();
    }, an = () => l.value ? _e() : q(), rn = (ne) => {
      o.value = ne;
    }, ln = () => {
      m.value.enabled && (S.value = !0, s()), a("focus");
    }, on = () => {
      m.value.enabled && (S.value = !1, $(t.modelValue)), a("blur");
    }, sn = (ne) => {
      P.value && P.value.updateMonthYear(0, {
        month: sa(ne.month),
        year: sa(ne.year)
      });
    }, un = (ne) => {
      $(ne ?? t.modelValue);
    }, dn = (ne, d) => {
      var T;
      (T = P.value) == null || T.switchView(ne, d);
    }, cn = (ne) => j.value.onClickOutside ? j.value.onClickOutside(ne) : _e();
    return bo(k, g, () => cn(fe)), n({
      closeMenu: _e,
      selectDate: R,
      clearValue: ce,
      openMenu: q,
      onScroll: U,
      formatInputValue: s,
      // exposed for testing purposes
      updateInternalModelValue: rn,
      // modify internal modelValue
      setMonthYear: sn,
      parseModel: un,
      switchView: dn
    }), (ne, d) => (D(), V("div", {
      class: he(pe.value),
      ref_key: "pickerWrapperRef",
      ref: Y
    }, [
      ze(cl, Ye({
        ref_key: "inputRef",
        ref: g,
        "is-menu-open": l.value,
        "input-value": f(i),
        "onUpdate:inputValue": d[0] || (d[0] = (T) => Qn(i) ? i.value = T : null)
      }, ne.$props, {
        onClear: ce,
        onOpen: q,
        onSetInputDate: Vt,
        onSetEmptyDate: f(Z),
        onSelectDate: R,
        onToggle: an,
        onClose: _e,
        onFocus: ln,
        onBlur: on,
        onRealBlur: d[1] || (d[1] = (T) => S.value = !1)
      }), Fe({ _: 2 }, [
        De(f(w), (T, ae) => ({
          name: T,
          fn: ie((se) => [
            te(ne.$slots, T, Pe(He(se)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      ze($t, {
        name: f(re)(f(L)),
        css: f(ue) && !f(C).enabled
      }, {
        default: ie(() => [
          l.value ? (D(), ve(In(ne.teleport ? Ga : "div"), Ye({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: k
          }, B.value, {
            class: { "dp--menu-wrapper": !f(C).enabled },
            style: f(C).enabled ? void 0 : f(x)
          }), {
            default: ie(() => [
              ze(ga, Ye({
                ref_key: "dpMenuRef",
                ref: P,
                class: { [u.value]: !0, "dp--menu-wrapper": ne.teleport },
                style: ne.teleport ? f(x) : void 0,
                "open-on-top": f(L),
                "arr-map-values": Q.value
              }, ne.$props, {
                "internal-model-value": f(o),
                "onUpdate:internalModelValue": d[2] || (d[2] = (T) => Qn(o) ? o.value = T : null),
                onClosePicker: _e,
                onSelectDate: R,
                onAutoApply: ee,
                onTimeUpdate: At,
                onFlowStep: d[3] || (d[3] = (T) => ne.$emit("flow-step", T)),
                onUpdateMonthYear: d[4] || (d[4] = (T) => ne.$emit("update-month-year", T)),
                onInvalidSelect: d[5] || (d[5] = (T) => ne.$emit("invalid-select", f(o))),
                onAutoApplyInvalid: d[6] || (d[6] = (T) => ne.$emit("invalid-select", T)),
                onInvalidFixedRange: d[7] || (d[7] = (T) => ne.$emit("invalid-fixed-range", T)),
                onRecalculatePosition: f(E),
                onTooltipOpen: d[8] || (d[8] = (T) => ne.$emit("tooltip-open", T)),
                onTooltipClose: d[9] || (d[9] = (T) => ne.$emit("tooltip-close", T)),
                onTimePickerOpen: d[10] || (d[10] = (T) => ne.$emit("time-picker-open", T)),
                onTimePickerClose: d[11] || (d[11] = (T) => ne.$emit("time-picker-close", T)),
                onAmPmChange: d[12] || (d[12] = (T) => ne.$emit("am-pm-change", T)),
                onRangeStart: d[13] || (d[13] = (T) => ne.$emit("range-start", T)),
                onRangeEnd: d[14] || (d[14] = (T) => ne.$emit("range-end", T))
              }), Fe({ _: 2 }, [
                De(f(y), (T, ae) => ({
                  name: T,
                  fn: ie((se) => [
                    te(ne.$slots, T, Pe(He({ ...se })))
                  ])
                }))
              ]), 1040, ["class", "style", "open-on-top", "arr-map-values", "internal-model-value", "onRecalculatePosition"])
            ]),
            _: 3
          }, 16, ["class", "style"])) : z("", !0)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 2));
  }
}), La = /* @__PURE__ */ (() => {
  const e = ko;
  return e.install = (n) => {
    n.component("Vue3DatePicker", e);
  }, e;
})(), wo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: La
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(wo).forEach(([e, n]) => {
  e !== "default" && (La[e] = n);
});
export {
  La as default
};
